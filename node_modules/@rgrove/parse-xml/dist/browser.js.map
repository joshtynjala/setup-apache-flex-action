{
  "version": 3,
  "sources": ["../src/index.ts", "../src/lib/StringScanner.ts", "../src/lib/syntax.ts", "../src/lib/XmlNode.ts", "../src/lib/XmlText.ts", "../src/lib/XmlCdata.ts", "../src/lib/XmlComment.ts", "../src/lib/XmlDeclaration.ts", "../src/lib/XmlElement.ts", "../src/lib/XmlDocument.ts", "../src/lib/XmlDocumentType.ts", "../src/lib/XmlError.ts", "../src/lib/XmlProcessingInstruction.ts", "../src/lib/Parser.ts"],
  "sourcesContent": ["import { Parser } from './lib/Parser.js';\n\nimport type { ParserOptions } from './lib/Parser.js';\n\nexport * from './lib/types.js';\nexport { XmlCdata } from './lib/XmlCdata.js';\nexport { XmlComment } from './lib/XmlComment.js';\nexport { XmlDeclaration } from './lib/XmlDeclaration.js';\nexport { XmlDocument } from './lib/XmlDocument.js';\nexport { XmlDocumentType } from './lib/XmlDocumentType.js';\nexport { XmlElement } from './lib/XmlElement.js';\nexport { XmlError } from './lib/XmlError.js';\nexport { XmlNode } from './lib/XmlNode.js';\nexport { XmlProcessingInstruction } from './lib/XmlProcessingInstruction.js';\nexport { XmlText } from './lib/XmlText.js';\n\nexport type { ParserOptions } from './lib/Parser.js';\n\n/**\n * Parses the given XML string and returns an `XmlDocument` instance\n * representing the document tree.\n *\n * @example\n *\n * import { parseXml } from '@rgrove/parse-xml';\n * let doc = parseXml('<kittens fuzzy=\"yes\">I like fuzzy kittens.</kittens>');\n *\n * @param xml XML string to parse.\n * @param options Parser options.\n */\nexport function parseXml(xml: string, options?: ParserOptions) {\n  return (new Parser(xml, options)).document;\n}\n", "const emptyString = '';\nconst surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\n/** @private */\nexport class StringScanner {\n  charIndex: number;\n  readonly string: string;\n\n  private readonly charCount: number;\n  private readonly charsToBytes: number[] | undefined;\n  private readonly length: number;\n  private readonly multiByteMode: boolean;\n\n  constructor(string: string) {\n    this.charCount = this.charLength(string, true);\n    this.charIndex = 0;\n    this.length = string.length;\n    this.multiByteMode = this.charCount !== this.length;\n    this.string = string;\n\n    if (this.multiByteMode) {\n      let charsToBytes = [];\n\n      // Create a mapping of character indexes to byte indexes. Since the string\n      // contains multibyte characters, a byte index may not necessarily align\n      // with a character index.\n      for (let byteIndex = 0, charIndex = 0; charIndex < this.charCount; ++charIndex) {\n        charsToBytes[charIndex] = byteIndex;\n        byteIndex += (string.codePointAt(byteIndex) as number) > 65535 ? 2 : 1;\n      }\n\n      this.charsToBytes = charsToBytes;\n    }\n  }\n\n  /**\n   * Whether the current character index is at the end of the input string.\n   */\n  get isEnd() {\n    return this.charIndex >= this.charCount;\n  }\n\n  // -- Protected Methods ------------------------------------------------------\n\n  /**\n   * Returns the number of characters in the given string, which may differ from\n   * the byte length if the string contains multibyte characters.\n   */\n  protected charLength(string: string, multiByteSafe = this.multiByteMode): number {\n    // We could get the char length with `[ ...string ].length`, but that's\n    // actually slower than replacing surrogate pairs with single-byte\n    // characters and then counting the result.\n    return multiByteSafe\n      ? string.replace(surrogatePair, '_').length\n      : string.length;\n  }\n\n  // -- Public Methods ---------------------------------------------------------\n\n  /**\n   * Advances the scanner by the given number of characters, stopping if the end\n   * of the string is reached.\n   */\n  advance(count = 1) {\n    this.charIndex = Math.min(this.charCount, this.charIndex + count);\n  }\n\n  /**\n   * Returns the byte index of the given character index in the string. The two\n   * may differ in strings that contain multibyte characters.\n   */\n  charIndexToByteIndex(charIndex: number = this.charIndex): number {\n    return this.multiByteMode\n      ? (this.charsToBytes as number[])[charIndex] ?? Infinity\n      : charIndex;\n  }\n\n  /**\n   * Consumes and returns the given number of characters if possible, advancing\n   * the scanner and stopping if the end of the string is reached.\n   *\n   * If no characters could be consumed, an empty string will be returned.\n   */\n  consume(count = 1): string {\n    let chars = this.peek(count);\n    this.advance(count);\n    return chars;\n  }\n\n  /**\n   * Consumes a match for the given sticky regex, advances the scanner, updates\n   * the `lastIndex` property of the regex, and returns the matching string.\n   *\n   * The regex must have a sticky flag (\"y\") so that its `lastIndex` prop can be\n   * used to anchor the match at the current scanner position.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeMatch(regex: RegExp): string {\n    if (!regex.sticky) {\n      throw new Error('`regex` must have a sticky flag (\"y\")');\n    }\n\n    regex.lastIndex = this.charIndexToByteIndex();\n\n    let result = regex.exec(this.string);\n\n    if (result === null || result.length === 0) {\n      return emptyString;\n    }\n\n    let match = result[0] as string;\n    this.advance(this.charLength(match));\n    return match;\n  }\n\n  /**\n   * Consumes and returns all characters for which the given function returns a\n   * truthy value, stopping on the first falsy return value or if the end of the\n   * input is reached.\n   */\n  consumeMatchFn(fn: (char: string) => boolean): string {\n    let char;\n    let match = emptyString;\n\n    while ((char = this.peek()) && fn(char)) {\n      match += char;\n      this.advance();\n    }\n\n    return match;\n  }\n\n  /**\n   * Consumes the given string if it exists at the current character index, and\n   * advances the scanner.\n   *\n   * If the given string doesn't exist at the current character index, an empty\n   * string will be returned and the scanner will not be advanced.\n   */\n  consumeString(stringToConsume: string): string {\n    if (this.consumeStringFast(stringToConsume)) {\n      return stringToConsume;\n    }\n\n    if (this.multiByteMode) {\n      let { length } = stringToConsume;\n      let charLengthToMatch = this.charLength(stringToConsume);\n\n      if (charLengthToMatch !== length\n          && stringToConsume === this.peek(charLengthToMatch)) {\n\n        this.advance(charLengthToMatch);\n        return stringToConsume;\n      }\n    }\n\n    return emptyString;\n  }\n\n  /**\n   * Does the same thing as `consumeString()`, but doesn't support consuming\n   * multibyte characters. This can be faster if you only need to match single\n   * byte characters.\n   */\n  consumeStringFast(stringToConsume: string): string {\n    let { length } = stringToConsume;\n\n    if (this.peek(length) === stringToConsume) {\n      this.advance(length);\n      return stringToConsume;\n    }\n\n    return emptyString;\n  }\n\n  /**\n   * Consumes characters until the given global regex is matched, advancing the\n   * scanner up to (but not beyond) the beginning of the match. If the regex\n   * doesn't match, nothing will be consumed.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeUntilMatch(regex: RegExp): string {\n    let restOfString = this.string.slice(this.charIndexToByteIndex());\n    let matchByteIndex = restOfString.search(regex);\n\n    if (matchByteIndex <= 0) {\n      return emptyString;\n    }\n\n    let result = restOfString.slice(0, matchByteIndex);\n    this.advance(this.charLength(result));\n    return result;\n  }\n\n  /**\n   * Consumes characters until the given string is found, advancing the scanner\n   * up to (but not beyond) that point. If the string is never found, nothing\n   * will be consumed.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeUntilString(searchString: string): string {\n    let { string } = this;\n    let byteIndex = this.charIndexToByteIndex();\n    let matchByteIndex = string.indexOf(searchString, byteIndex);\n\n    if (matchByteIndex <= 0) {\n      return emptyString;\n    }\n\n    let result = string.slice(byteIndex, matchByteIndex);\n    this.advance(this.charLength(result));\n    return result;\n  }\n\n  /**\n   * Returns the given number of characters starting at the current character\n   * index, without advancing the scanner and without exceeding the end of the\n   * input string.\n   */\n  peek(count = 1): string {\n    let { charIndex, multiByteMode, string } = this;\n\n    if (multiByteMode) {\n      // Inlining this comparison instead of checking `this.isEnd` improves perf\n      // slightly since `peek()` is called so frequently.\n      if (charIndex >= this.charCount) {\n        return emptyString;\n      }\n\n      return string.slice(\n        this.charIndexToByteIndex(charIndex),\n        this.charIndexToByteIndex(charIndex + count),\n      );\n    }\n\n    return string.slice(charIndex, charIndex + count);\n  }\n\n  /**\n   * Resets the scanner position to the given character _index_, or to the start\n   * of the input string if no index is given.\n   *\n   * If _index_ is negative, the scanner position will be moved backward by that\n   * many characters, stopping if the beginning of the string is reached.\n   */\n  reset(index = 0) {\n    this.charIndex = index >= 0\n      ? Math.min(this.charCount, index)\n      : Math.max(0, this.charIndex + index);\n  }\n}\n", "/**\n * Regular expression that matches one or more `AttValue` characters in a\n * double-quoted attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n */\nexport const attValueCharDoubleQuote = /[^\"&<]+/y;\n\n/**\n * Regular expression that matches one or more `AttValue` characters in a\n * single-quoted attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n */\nexport const attValueCharSingleQuote = /[^'&<]+/y;\n\n/**\n * Regular expression that matches a whitespace character that should be\n * normalized to a space character in an attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#AVNormalize\n */\nexport const attValueNormalizedWhitespace = /\\r\\n|[\\n\\r\\t]/g;\n\n/**\n * Regular expression that matches one or more characters that signal the end of\n * XML `CharData` content.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n */\nexport const endCharData = /<|&|]]>/;\n\n/**\n * Mapping of predefined entity names to their replacement values.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent\n */\nexport const predefinedEntities: Readonly<{[name: string]: string;}> = Object.freeze(Object.assign(Object.create(null), {\n  amp: '&',\n  apos: \"'\",\n  gt: '>',\n  lt: '<',\n  quot: '\"',\n}));\n\n/**\n * Returns `true` if _char_ is an XML `NameChar`, `false` if it isn't.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameChar\n */\nexport function isNameChar(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  // Including the most common NameStartChars here improves performance\n  // slightly.\n  return (cp >= 0x61 && cp <= 0x7A) // a-z\n    || (cp >= 0x41 && cp <= 0x5A) // A-Z\n    || (cp >= 0x30 && cp <= 0x39) // 0-9\n    || cp === 0x2D // -\n    || cp === 0x2E // .\n    || cp === 0xB7\n    || (cp >= 0x300 && cp <= 0x36F)\n    || (cp >= 0x203F && cp <= 0x2040)\n    || isNameStartChar(char, cp);\n}\n\n/**\n * Returns `true` if _char_ is an XML `NameStartChar`, `false` if it isn't.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameStartChar\n */\nexport function isNameStartChar(char: string, cp = getCodePoint(char)): boolean {\n  return (cp >= 0x61 && cp <= 0x7A) // a-z\n    || (cp >= 0x41 && cp <= 0x5A) // A-Z\n    || cp === 0x3A // :\n    || cp === 0x5F // _\n    || (cp >= 0xC0 && cp <= 0xD6)\n    || (cp >= 0xD8 && cp <= 0xF6)\n    || (cp >= 0xF8 && cp <= 0x2FF)\n    || (cp >= 0x370 && cp <= 0x37D)\n    || (cp >= 0x37F && cp <= 0x1FFF)\n    || (cp >= 0x200C && cp <= 0x200D)\n    || (cp >= 0x2070 && cp <= 0x218F)\n    || (cp >= 0x2C00 && cp <= 0x2FEF)\n    || (cp >= 0x3001 && cp <= 0xD7FF)\n    || (cp >= 0xF900 && cp <= 0xFDCF)\n    || (cp >= 0xFDF0 && cp <= 0xFFFD)\n    || (cp >= 0x10000 && cp <= 0xEFFFF);\n}\n\n/**\n * Returns `true` if _char_ is a valid reference character (which may appear\n * between `&` and `;` in a reference), `false` otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-references\n */\nexport function isReferenceChar(char: string): boolean {\n  return char === '#' || isNameChar(char);\n}\n\n/**\n * Returns `true` if _char_ is an XML whitespace character, `false` otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n */\nexport function isWhitespace(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  return cp === 0x20\n    || cp === 0x9\n    || cp === 0xA\n    || cp === 0xD;\n}\n\n/**\n * Returns `true` if _codepoint_ is a valid XML `Char` code point, `false`\n * otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Char\n */\nexport function isXmlCodePoint(cp: number): boolean {\n  return cp === 0x9\n    || cp === 0xA\n    || cp === 0xD\n    || (cp >= 0x20 && cp <= 0xD7FF)\n    || (cp >= 0xE000 && cp <= 0xFFFD)\n    || (cp >= 0x10000 && cp <= 0x10FFFF);\n}\n\n/**\n * Returns the Unicode code point value of the given character, or `-1` if\n * _char_ is empty.\n */\nfunction getCodePoint(char: string): number {\n  return char.codePointAt(0) || -1;\n}\n", "import type { JsonObject } from './types.js';\nimport type { XmlDocument } from './XmlDocument.js';\nimport type { XmlElement } from './XmlElement.js';\n\n/**\n * Base interface for a node in an XML document.\n */\nexport class XmlNode {\n  /**\n   * Type value for an `XmlCdata` node.\n   */\n  static readonly TYPE_CDATA = 'cdata';\n\n  /**\n   * Type value for an `XmlComment` node.\n   */\n  static readonly TYPE_COMMENT = 'comment';\n\n  /**\n   * Type value for an `XmlDocument` node.\n   */\n  static readonly TYPE_DOCUMENT = 'document';\n\n  /**\n   * Type value for an `XmlDocumentType` node.\n   */\n  static readonly TYPE_DOCUMENT_TYPE = 'doctype';\n\n  /**\n   * Type value for an `XmlElement` node.\n   */\n  static readonly TYPE_ELEMENT = 'element';\n\n  /**\n   * Type value for an `XmlProcessingInstruction` node.\n   */\n  static readonly TYPE_PROCESSING_INSTRUCTION = 'pi';\n\n  /**\n   * Type value for an `XmlText` node.\n   */\n  static readonly TYPE_TEXT = 'text';\n\n  /**\n   * Type value for an `XmlDeclaration` node.\n   */\n  static readonly TYPE_XML_DECLARATION = 'xmldecl';\n\n  /**\n   * Parent node of this node, or `null` if this node has no parent.\n   */\n  parent: XmlDocument | XmlElement | null = null;\n\n  /**\n   * Starting byte offset of this node in the original XML string, or `-1` if\n   * the offset is unknown.\n   */\n  start = -1;\n\n  /**\n   * Ending byte offset of this node in the original XML string, or `-1` if the\n   * offset is unknown.\n   */\n  end = -1;\n\n  /**\n   * Document that contains this node, or `null` if this node is not associated\n   * with a document.\n   */\n  get document(): XmlDocument | null {\n    return this.parent?.document ?? null;\n  }\n\n  /**\n   * Whether this node is the root node of the document (also known as the\n   * document element).\n   */\n  get isRootNode(): boolean {\n    return this.parent !== null\n      && this.parent === this.document\n      && this.type === XmlNode.TYPE_ELEMENT;\n  }\n\n  /**\n   * Whether whitespace should be preserved in the content of this element and\n   * its children.\n   *\n   * This is influenced by the value of the special `xml:space` attribute, and\n   * will be `true` for any node whose `xml:space` attribute is set to\n   * \"preserve\". If a node has no such attribute, it will inherit the value of\n   * the nearest ancestor that does (if any).\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space\n   */\n  get preserveWhitespace(): boolean {\n    return !!this.parent?.preserveWhitespace;\n  }\n\n  /**\n   * Type of this node.\n   *\n   * The value of this property is a string that matches one of the static\n   * `TYPE_*` properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`,\n   * `TYPE_TEXT`, etc.).\n   *\n   * The `XmlNode` class itself is a base class and doesn't have its own type\n   * name.\n   */\n  get type() {\n    return '';\n  }\n\n  /**\n   * Returns a JSON-serializable object representing this node, minus properties\n   * that could result in circular references.\n   */\n  toJSON(): JsonObject {\n    let json: JsonObject = {\n      type: this.type,\n    };\n\n    if (this.isRootNode) {\n      json.isRootNode = true;\n    }\n\n    if (this.preserveWhitespace) {\n      json.preserveWhitespace = true;\n    }\n\n    if (this.start !== -1) {\n      json.start = this.start;\n      json.end = this.end;\n    }\n\n    return json;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * Text content within an XML document.\n */\nexport class XmlText extends XmlNode {\n  /**\n   * Text content of this node.\n   */\n  text: string;\n\n  constructor(text = '') {\n    super();\n    this.text = text;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_TEXT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      text: this.text,\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\nimport { XmlText } from './XmlText.js';\n\n/**\n * A CDATA section within an XML document.\n */\nexport class XmlCdata extends XmlText {\n  override get type() {\n    return XmlNode.TYPE_CDATA;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * A comment within an XML document.\n */\nexport class XmlComment extends XmlNode {\n  /**\n   * Content of this comment.\n   */\n  content: string;\n\n  constructor(content = '') {\n    super();\n    this.content = content;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_COMMENT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      content: this.content,\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * An XML declaration within an XML document.\n *\n * @example\n *\n * ```xml\n * <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n * ```\n */\nexport class XmlDeclaration extends XmlNode {\n  /**\n   * Value of the encoding declaration in this XML declaration, or `null` if no\n   * encoding declaration was present.\n   */\n  encoding: string | null;\n\n  /**\n   * Value of the standalone declaration in this XML declaration, or `null` if\n   * no standalone declaration was present.\n   */\n  standalone: 'yes' | 'no' | null;\n\n  /**\n   * Value of the version declaration in this XML declaration.\n   */\n  version: string;\n\n  constructor(\n    version: string,\n    encoding?: string,\n    standalone?: typeof XmlDeclaration.prototype.standalone,\n  ) {\n    super();\n\n    this.version = version;\n    this.encoding = encoding ?? null;\n    this.standalone = standalone ?? null;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_XML_DECLARATION;\n  }\n\n  override toJSON() {\n    let json = XmlNode.prototype.toJSON.call(this);\n    json.version = this.version;\n\n    for (let key of ['encoding', 'standalone'] as const) {\n      if (this[key] !== null) {\n        json[key] = this[key];\n      }\n    }\n\n    return json;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\nimport type { JsonObject } from './types.js';\nimport type { XmlCdata } from './XmlCdata.js';\nimport type { XmlComment } from './XmlComment.js';\nimport type { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\nimport type { XmlText } from './XmlText.js';\n\n/**\n * Element in an XML document.\n */\nexport class XmlElement extends XmlNode {\n  /**\n   * Attributes on this element.\n   */\n  attributes: {[attrName: string]: string};\n\n  /**\n   * Child nodes of this element.\n   */\n  children: Array<XmlCdata | XmlComment | XmlElement | XmlProcessingInstruction | XmlText>;\n\n  /**\n   * Name of this element.\n   */\n  name: string;\n\n  constructor(\n    name: string,\n    attributes: {[attrName: string]: string} = Object.create(null),\n    children: Array<XmlCdata | XmlComment | XmlElement | XmlProcessingInstruction | XmlText> = [],\n  ) {\n    super();\n\n    this.name = name;\n    this.attributes = attributes;\n    this.children = children;\n  }\n\n  /**\n   * Whether this element is empty (meaning it has no children).\n   */\n  get isEmpty(): boolean {\n    return this.children.length === 0;\n  }\n\n  override get preserveWhitespace(): boolean {\n    let node: XmlNode | null = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    while (node instanceof XmlElement) {\n      if ('xml:space' in node.attributes) {\n        return node.attributes['xml:space'] === 'preserve';\n      }\n\n      node = node.parent;\n    }\n\n    return false;\n  }\n\n  /**\n   * Text content of this element and all its descendants.\n   */\n  get text(): string {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  override get type() {\n    return XmlNode.TYPE_ELEMENT;\n  }\n\n  override toJSON(): JsonObject {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      attributes: this.attributes,\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n", "import { XmlElement } from './XmlElement.js';\nimport { XmlNode } from './XmlNode.js';\n\nimport type { XmlComment } from './XmlComment.js';\nimport type { XmlDeclaration } from './XmlDeclaration.js';\nimport type { XmlDocumentType } from './XmlDocumentType.js';\nimport type { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\n\n/**\n * Represents an XML document. All elements within the document are descendants\n * of this node.\n */\nexport class XmlDocument extends XmlNode {\n  /**\n   * Child nodes of this document.\n   */\n  readonly children: Array<XmlComment | XmlDeclaration | XmlDocumentType | XmlProcessingInstruction | XmlElement>;\n\n  constructor(children: Array<XmlComment | XmlDeclaration | XmlDocumentType | XmlElement | XmlProcessingInstruction> = []) {\n    super();\n    this.children = children;\n  }\n\n  override get document() {\n    return this;\n  }\n\n  /**\n   * Root element of this document, or `null` if this document is empty.\n   */\n  get root(): XmlElement | null {\n    for (let child of this.children) {\n      if (child instanceof XmlElement) {\n        return child;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Text content of this document and all its descendants.\n   */\n  get text(): string {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  override get type() {\n    return XmlNode.TYPE_DOCUMENT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * A document type declaration within an XML document.\n *\n * @example\n *\n * ```xml\n * <!DOCTYPE kittens [\n *   <!ELEMENT kittens (#PCDATA)>\n * ]>\n * ```\n */\nexport class XmlDocumentType extends XmlNode {\n  /**\n   * Name of the root element described by this document type declaration.\n   */\n  name: string;\n\n  /**\n   * Public identifier of the external subset of this document type declaration,\n   * or `null` if no public identifier was present.\n   */\n  publicId: string | null;\n\n  /**\n   * System identifier of the external subset of this document type declaration,\n   * or `null` if no system identifier was present.\n   */\n  systemId: string | null;\n\n  /**\n   * Internal subset of this document type declaration, or `null` if no internal\n   * subset was present.\n   */\n  internalSubset: string | null;\n\n  constructor(\n    name: string,\n    publicId?: string,\n    systemId?: string,\n    internalSubset?: string,\n  ) {\n    super();\n    this.name = name;\n    this.publicId = publicId ?? null;\n    this.systemId = systemId ?? null;\n    this.internalSubset = internalSubset ?? null;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_DOCUMENT_TYPE;\n  }\n\n  override toJSON() {\n    let json = XmlNode.prototype.toJSON.call(this);\n    json.name = this.name;\n\n    for (let key of ['publicId', 'systemId', 'internalSubset'] as const) {\n      if (this[key] !== null) {\n        json[key] = this[key];\n      }\n    }\n\n    return json;\n  }\n}\n", "/**\n * An error that occurred while parsing XML.\n */\nexport class XmlError extends Error {\n  /**\n   * Character column at which this error occurred (1-based).\n   */\n  readonly column: number;\n\n  /**\n   * Short excerpt from the input string that contains the problem.\n   */\n  readonly excerpt: string;\n\n  /**\n   * Line number at which this error occurred (1-based).\n   */\n  readonly line: number;\n\n  /**\n   * Character position at which this error occurred relative to the beginning\n   * of the input (0-based).\n   */\n  readonly pos: number;\n\n  constructor(\n    message: string,\n    charIndex: number,\n    xml: string,\n  ) {\n    let column = 1;\n    let excerpt = '';\n    let line = 1;\n\n    // Find the line and column where the error occurred.\n    for (let i = 0; i < charIndex; ++i) {\n      let char = xml[i];\n\n      if (char === '\\n') {\n        column = 1;\n        excerpt = '';\n        line += 1;\n      } else {\n        column += 1;\n        excerpt += char;\n      }\n    }\n\n    let eol = xml.indexOf('\\n', charIndex);\n\n    excerpt += eol === -1\n      ? xml.slice(charIndex)\n      : xml.slice(charIndex, eol);\n\n    let excerptStart = 0;\n\n    // Keep the excerpt below 50 chars, but always keep the error position in\n    // view.\n    if (excerpt.length > 50) {\n      if (column < 40) {\n        excerpt = excerpt.slice(0, 50);\n      } else {\n        excerptStart = column - 20;\n        excerpt = excerpt.slice(excerptStart, column + 30);\n      }\n    }\n\n    super(\n      `${message} (line ${line}, column ${column})\\n`\n        + `  ${excerpt}\\n`\n        + ' '.repeat(column - excerptStart + 1) + '^\\n',\n    );\n\n    this.column = column;\n    this.excerpt = excerpt;\n    this.line = line;\n    this.name = 'XmlError';\n    this.pos = charIndex;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * A processing instruction within an XML document.\n */\nexport class XmlProcessingInstruction extends XmlNode {\n  /**\n   * Content of this processing instruction.\n   */\n  content: string;\n\n  /**\n   * Name of this processing instruction. Also sometimes referred to as the\n   * processing instruction \"target\".\n   */\n  name: string;\n\n  constructor(name: string, content = '') {\n    super();\n\n    this.name = name;\n    this.content = content;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_PROCESSING_INSTRUCTION;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      content: this.content,\n    });\n  }\n}\n", "import { StringScanner } from './StringScanner.js';\nimport * as syntax from './syntax.js';\nimport { XmlCdata } from './XmlCdata.js';\nimport { XmlComment } from './XmlComment.js';\nimport { XmlDeclaration } from './XmlDeclaration.js';\nimport { XmlDocument } from './XmlDocument.js';\nimport { XmlDocumentType } from './XmlDocumentType.js';\nimport { XmlElement } from './XmlElement.js';\nimport { XmlError } from './XmlError.js';\nimport { XmlNode } from './XmlNode.js';\nimport { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\nimport { XmlText } from './XmlText.js';\n\nconst emptyString = '';\n\n/**\n * Parses an XML string into an `XmlDocument`.\n *\n * @private\n */\nexport class Parser {\n  readonly document: XmlDocument;\n\n  private currentNode: XmlDocument | XmlElement;\n  private readonly options: ParserOptions;\n  private readonly scanner: StringScanner;\n\n  /**\n   * @param xml XML string to parse.\n   * @param options Parser options.\n   */\n  constructor(xml: string, options: ParserOptions = {}) {\n    let doc = this.document = new XmlDocument();\n    let scanner = this.scanner = new StringScanner(xml);\n\n    this.currentNode = doc;\n    this.options = options;\n\n    if (this.options.includeOffsets) {\n      doc.start = 0;\n      doc.end = xml.length;\n    }\n\n    scanner.consumeStringFast('\\uFEFF'); // byte order mark\n    this.consumeProlog();\n\n    if (!this.consumeElement()) {\n      throw this.error('Root element is missing or invalid');\n    }\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (!scanner.isEnd) {\n      throw this.error('Extra content at the end of the document');\n    }\n  }\n\n  /**\n   * Adds the given `XmlNode` as a child of `this.currentNode`.\n   */\n  addNode(node: XmlNode, charIndex: number) {\n    node.parent = this.currentNode;\n\n    if (this.options.includeOffsets) {\n      node.start = this.scanner.charIndexToByteIndex(charIndex);\n      node.end = this.scanner.charIndexToByteIndex();\n    }\n\n    // @ts-expect-error: XmlDocument has a more limited set of possible children\n    // than XmlElement so TypeScript is unhappy, but we always do the right\n    // thing.\n    this.currentNode.children.push(node);\n    return true;\n  }\n\n  /**\n   * Adds the given _text_ to the document, either by appending it to a\n   * preceding `XmlText` node (if possible) or by creating a new `XmlText` node.\n   */\n  addText(text: string, charIndex: number) {\n    let { children } = this.currentNode;\n    let { length } = children;\n\n    text = normalizeLineBreaks(text);\n\n    if (length > 0) {\n      let prevNode = children[length - 1];\n\n      if (prevNode?.type === XmlNode.TYPE_TEXT) {\n        let textNode = prevNode as XmlText;\n\n        // The previous node is a text node, so we can append to it and avoid\n        // creating another node.\n        textNode.text += text;\n\n        if (this.options.includeOffsets) {\n          textNode.end = this.scanner.charIndexToByteIndex();\n        }\n\n        return true;\n      }\n    }\n\n    return this.addNode(new XmlText(text), charIndex);\n  }\n\n  /**\n   * Consumes element attributes.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-starttags\n   */\n  consumeAttributes(): Record<string, string> {\n    let attributes = Object.create(null);\n\n    while (this.consumeWhitespace()) {\n      let attrName = this.consumeName();\n\n      if (!attrName) {\n        break;\n      }\n\n      let attrValue = this.consumeEqual() && this.consumeAttributeValue();\n\n      if (attrValue === false) {\n        throw this.error('Attribute value expected');\n      }\n\n      if (attrName in attributes) {\n        throw this.error(`Duplicate attribute: ${attrName}`);\n      }\n\n      if (attrName === 'xml:space'\n          && attrValue !== 'default'\n          && attrValue !== 'preserve') {\n\n        throw this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n      }\n\n      attributes[attrName] = attrValue;\n    }\n\n    if (this.options.sortAttributes) {\n      let attrNames = Object.keys(attributes).sort();\n      let sortedAttributes = Object.create(null);\n\n      for (let i = 0; i < attrNames.length; ++i) {\n        let attrName = attrNames[i] as string;\n        sortedAttributes[attrName] = attributes[attrName];\n      }\n\n      attributes = sortedAttributes;\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Consumes an `AttValue` (attribute value) if possible.\n   *\n   * @returns\n   *   Contents of the `AttValue` minus quotes, or `false` if nothing was\n   *   consumed. An empty string indicates that an `AttValue` was consumed but\n   *   was empty.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n   */\n  consumeAttributeValue(): string | false {\n    let { scanner } = this;\n    let quote = scanner.peek();\n\n    if (quote !== '\"' && quote !== \"'\") {\n      return false;\n    }\n\n    scanner.advance();\n\n    let chars;\n    let isClosed = false;\n    let value = emptyString;\n    let regex = quote === '\"'\n      ? syntax.attValueCharDoubleQuote\n      : syntax.attValueCharSingleQuote;\n\n    matchLoop: while (!scanner.isEnd) {\n      chars = scanner.consumeMatch(regex);\n\n      if (chars) {\n        this.validateChars(chars);\n        value += chars.replace(syntax.attValueNormalizedWhitespace, ' ');\n      }\n\n      switch (scanner.peek()) {\n        case quote:\n          isClosed = true;\n          break matchLoop;\n\n        case '&':\n          value += this.consumeReference();\n          continue;\n\n        case '<':\n          throw this.error('Unescaped `<` is not allowed in an attribute value');\n\n        case emptyString:\n          break matchLoop;\n      }\n    }\n\n    if (!isClosed) {\n      throw this.error('Unclosed attribute');\n    }\n\n    scanner.advance();\n    return value;\n  }\n\n  /**\n   * Consumes a CDATA section if possible.\n   *\n   * @returns Whether a CDATA section was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n   */\n  consumeCdataSection(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<![CDATA[')) {\n      return false;\n    }\n\n    let text = scanner.consumeUntilString(']]>');\n    this.validateChars(text);\n\n    if (!scanner.consumeStringFast(']]>')) {\n      throw this.error('Unclosed CDATA section');\n    }\n\n    return this.options.preserveCdata\n      ? this.addNode(new XmlCdata(normalizeLineBreaks(text)), startIndex)\n      : this.addText(text, startIndex);\n  }\n\n  /**\n   * Consumes character data if possible.\n   *\n   * @returns Whether character data was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n   */\n  consumeCharData(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n    let charData = scanner.consumeUntilMatch(syntax.endCharData);\n\n    if (!charData) {\n      return false;\n    }\n\n    this.validateChars(charData);\n\n    if (scanner.peek(3) === ']]>') {\n      throw this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n    }\n\n    return this.addText(charData, startIndex);\n  }\n\n  /**\n   * Consumes a comment if possible.\n   *\n   * @returns Whether a comment was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n   */\n  consumeComment(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<!--')) {\n      return false;\n    }\n\n    let content = scanner.consumeUntilString('--');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('-->')) {\n      if (scanner.peek(2) === '--') {\n        throw this.error(\"The string `--` isn't allowed inside a comment\");\n      }\n\n      throw this.error('Unclosed comment');\n    }\n\n    return this.options.preserveComments\n      ? this.addNode(new XmlComment(normalizeLineBreaks(content)), startIndex)\n      : true;\n  }\n\n  /**\n   * Consumes a reference in a content context if possible.\n   *\n   * This differs from `consumeReference()` in that a consumed reference will be\n   * added to the document as a text node instead of returned.\n   *\n   * @returns Whether a reference was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n   */\n  consumeContentReference(): boolean {\n    let startIndex = this.scanner.charIndex;\n    let ref = this.consumeReference();\n\n    return ref\n      ? this.addText(ref, startIndex)\n      : false;\n  }\n\n  /**\n   * Consumes a doctype declaration if possible.\n   *\n   * This is a loose implementation since doctype declarations are currently\n   * discarded without further parsing.\n   *\n   * @returns Whether a doctype declaration was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n   */\n  consumeDoctypeDeclaration(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<!DOCTYPE')) {\n      return false;\n    }\n\n    let name = this.consumeWhitespace()\n      && this.consumeName();\n\n    if (!name) {\n      throw this.error('Expected a name');\n    }\n\n    let publicId;\n    let systemId;\n\n    if (this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('PUBLIC')) {\n        publicId = this.consumeWhitespace()\n          && this.consumePubidLiteral();\n\n        if (publicId === false) {\n          throw this.error('Expected a public identifier');\n        }\n\n        this.consumeWhitespace();\n      }\n\n      if (publicId !== undefined || scanner.consumeStringFast('SYSTEM')) {\n        this.consumeWhitespace();\n        systemId = this.consumeSystemLiteral();\n\n        if (systemId === false) {\n          throw this.error('Expected a system identifier');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    let internalSubset;\n\n    if (scanner.consumeStringFast('[')) {\n      // The internal subset may contain comments that contain `]` characters,\n      // so we can't use `consumeUntilString()` here.\n      internalSubset = scanner.consumeUntilMatch(/\\][\\x20\\t\\r\\n]*>/);\n\n      if (!scanner.consumeStringFast(']')) {\n        throw this.error('Unclosed internal subset');\n      }\n\n      this.consumeWhitespace();\n    }\n\n    if (!scanner.consumeStringFast('>')) {\n      throw this.error('Unclosed doctype declaration');\n    }\n\n    return this.options.preserveDocumentType\n      ? this.addNode(new XmlDocumentType(name, publicId, systemId, internalSubset), startIndex)\n      : true;\n    }\n\n  /**\n   * Consumes an element if possible.\n   *\n   * @returns Whether an element was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n   */\n  consumeElement(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (!name) {\n      scanner.reset(startIndex);\n      return false;\n    }\n\n    let attributes = this.consumeAttributes();\n    let isEmpty = !!scanner.consumeStringFast('/>');\n    let element = new XmlElement(name, attributes);\n\n    element.parent = this.currentNode;\n\n    if (!isEmpty) {\n      if (!scanner.consumeStringFast('>')) {\n        throw this.error(`Unclosed start tag for element \\`${name}\\``);\n      }\n\n      this.currentNode = element;\n\n      do {\n        this.consumeCharData();\n      } while (\n        this.consumeElement()\n          || this.consumeContentReference()\n          || this.consumeCdataSection()\n          || this.consumeProcessingInstruction()\n          || this.consumeComment()\n      );\n\n      let endTagMark = scanner.charIndex;\n      let endTagName;\n\n      if (!scanner.consumeStringFast('</')\n          || !(endTagName = this.consumeName())\n          || endTagName !== name) {\n\n        scanner.reset(endTagMark);\n        throw this.error(`Missing end tag for element ${name}`);\n      }\n\n      this.consumeWhitespace();\n\n      if (!scanner.consumeStringFast('>')) {\n        throw this.error(`Unclosed end tag for element ${name}`);\n      }\n\n      this.currentNode = element.parent;\n    }\n\n    return this.addNode(element, startIndex);\n  }\n\n  /**\n   * Consumes an `Eq` production if possible.\n   *\n   * @returns Whether an `Eq` production was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n   */\n  consumeEqual(): boolean {\n    this.consumeWhitespace();\n\n    if (this.scanner.consumeStringFast('=')) {\n      this.consumeWhitespace();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Consumes `Misc` content if possible.\n   *\n   * @returns Whether anything was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n   */\n  consumeMisc(): boolean {\n    return this.consumeComment()\n      || this.consumeProcessingInstruction()\n      || this.consumeWhitespace();\n  }\n\n  /**\n   * Consumes one or more `Name` characters if possible.\n   *\n   * @returns `Name` characters, or an empty string if none were consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n   */\n  consumeName(): string {\n    return syntax.isNameStartChar(this.scanner.peek())\n      ? this.scanner.consumeMatchFn(syntax.isNameChar)\n      : emptyString;\n  }\n\n  /**\n   * Consumes a processing instruction if possible.\n   *\n   * @returns Whether a processing instruction was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n   */\n  consumeProcessingInstruction(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (name) {\n      if (name.toLowerCase() === 'xml') {\n        scanner.reset(startIndex);\n        throw this.error(\"XML declaration isn't allowed here\");\n      }\n    } else {\n      throw this.error('Invalid processing instruction');\n    }\n\n    if (!this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('?>')) {\n        return this.addNode(new XmlProcessingInstruction(name), startIndex);\n      }\n\n      throw this.error('Whitespace is required after a processing instruction name');\n    }\n\n    let content = scanner.consumeUntilString('?>');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('?>')) {\n      throw this.error('Unterminated processing instruction');\n    }\n\n    return this.addNode(new XmlProcessingInstruction(name, normalizeLineBreaks(content)), startIndex);\n  }\n\n  /**\n   * Consumes a prolog if possible.\n   *\n   * @returns Whether a prolog was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n   */\n  consumeProlog(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    this.consumeXmlDeclaration();\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (this.consumeDoctypeDeclaration()) {\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n    }\n\n    return startIndex < scanner.charIndex;\n  }\n\n  /**\n   * Consumes a public identifier literal if possible.\n   *\n   * @returns\n   *   Value of the public identifier literal minus quotes, or `false` if\n   *   nothing was consumed. An empty string indicates that a public id literal\n   *   was consumed but was empty.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-PubidLiteral\n   */\n  consumePubidLiteral(): string | false {\n    let startIndex = this.scanner.charIndex;\n    let value = this.consumeSystemLiteral();\n\n    if (value !== false && !/^[-\\x20\\r\\na-zA-Z0-9'()+,./:=?;!*#@$_%]*$/.test(value)) {\n      this.scanner.reset(startIndex);\n      throw this.error('Invalid character in public identifier');\n    }\n\n    return value;\n  }\n\n  /**\n   * Consumes a reference if possible.\n   *\n   * This differs from `consumeContentReference()` in that a consumed reference\n   * will be returned rather than added to the document.\n   *\n   * @returns\n   *   Parsed reference value, or `false` if nothing was consumed (to\n   *   distinguish from a reference that resolves to an empty string).\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n   */\n  consumeReference(): string | false {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('&')) {\n      return false;\n    }\n\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n\n    if (scanner.consume() !== ';') {\n      throw this.error('Unterminated reference (a reference must end with `;`)');\n    }\n\n    let parsedValue;\n\n    if (ref[0] === '#') {\n      // This is a character reference.\n      let codePoint = ref[1] === 'x'\n        ? parseInt(ref.slice(2), 16) // Hex codepoint.\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n      if (isNaN(codePoint)) {\n        throw this.error('Invalid character reference');\n      }\n\n      if (!syntax.isXmlCodePoint(codePoint)) {\n        throw this.error('Character reference resolves to an invalid character');\n      }\n\n      parsedValue = String.fromCodePoint(codePoint);\n    } else {\n      // This is an entity reference.\n      parsedValue = syntax.predefinedEntities[ref];\n\n      if (parsedValue === undefined) {\n        let {\n          ignoreUndefinedEntities,\n          resolveUndefinedEntity,\n        } = this.options;\n\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n\n        if (resolveUndefinedEntity) {\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\n\n          if (resolvedValue !== null && resolvedValue !== undefined) {\n            let type = typeof resolvedValue;\n\n            if (type !== 'string') {\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n            }\n\n            return resolvedValue;\n          }\n        }\n\n        if (ignoreUndefinedEntities) {\n          return wrappedRef;\n        }\n\n        scanner.reset(-wrappedRef.length);\n        throw this.error(`Named entity isn't defined: ${wrappedRef}`);\n      }\n    }\n\n    return parsedValue;\n  }\n\n  /**\n   * Consumes a `SystemLiteral` if possible.\n   *\n   * A `SystemLiteral` is similar to an attribute value, but allows the\n   * characters `<` and `&` and doesn't replace references.\n   *\n   * @returns\n   *   Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n   *   consumed. An empty string indicates that a `SystemLiteral` was consumed\n   *   but was empty.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n   */\n  consumeSystemLiteral(): string | false {\n    let { scanner } = this;\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n\n    if (!quote) {\n      return false;\n    }\n\n    let value = scanner.consumeUntilString(quote);\n    this.validateChars(value);\n\n    if (!scanner.consumeStringFast(quote)) {\n      throw this.error('Missing end quote');\n    }\n\n    return value;\n  }\n\n  /**\n   * Consumes one or more whitespace characters if possible.\n   *\n   * @returns Whether any whitespace characters were consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n   */\n  consumeWhitespace(): boolean {\n    return !!this.scanner.consumeMatchFn(syntax.isWhitespace);\n  }\n\n  /**\n   * Consumes an XML declaration if possible.\n   *\n   * @returns Whether an XML declaration was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n   */\n  consumeXmlDeclaration(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?xml')) {\n      return false;\n    }\n\n    if (!this.consumeWhitespace()) {\n      throw this.error('Invalid XML declaration');\n    }\n\n    let version = !!scanner.consumeStringFast('version')\n      && this.consumeEqual()\n      && this.consumeSystemLiteral();\n\n    if (version === false) {\n      throw this.error('XML version is missing or invalid');\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\n      throw this.error('Invalid character in version number');\n    }\n\n    let encoding;\n    let standalone;\n\n    if (this.consumeWhitespace()) {\n      encoding = !!scanner.consumeStringFast('encoding')\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (encoding) {\n        this.consumeWhitespace();\n      }\n\n      standalone = !!scanner.consumeStringFast('standalone')\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (standalone) {\n        if (standalone !== 'yes' && standalone !== 'no') {\n          throw this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    if (!scanner.consumeStringFast('?>')) {\n      throw this.error('Invalid or unclosed XML declaration');\n    }\n\n    return this.options.preserveXmlDeclaration\n      ? this.addNode(new XmlDeclaration(\n          version,\n          encoding || undefined,\n          (standalone as 'yes' | 'no' | false) || undefined,\n        ), startIndex)\n      : true;\n  }\n\n  /**\n   * Returns an `XmlError` for the current scanner position.\n   */\n  error(message: string) {\n    let { scanner } = this;\n    return new XmlError(message, scanner.charIndex, scanner.string);\n  }\n\n  /**\n   * Throws an invalid character error if any character in the given _string_\n   * isn't a valid XML character.\n   */\n  validateChars(string: string) {\n    let { length } = string;\n\n    for (let i = 0; i < length; ++i) {\n      let cp = string.codePointAt(i) as number;\n\n      if (!syntax.isXmlCodePoint(cp)) {\n        this.scanner.reset(-([ ...string ].length - i));\n        throw this.error('Invalid character');\n      }\n\n      if (cp > 65535) {\n        i += 1;\n      }\n    }\n  }\n}\n\n// -- Private Functions --------------------------------------------------------\n\n/**\n * Normalizes line breaks in the given text by replacing CRLF sequences and lone\n * CR characters with LF characters.\n */\nfunction normalizeLineBreaks(text: string): string {\n  let i = 0;\n\n  while ((i = text.indexOf('\\r', i)) !== -1) {\n    text = text[i + 1] === '\\n'\n      ? text.slice(0, i) + text.slice(i + 1)\n      : text.slice(0, i) + '\\n' + text.slice(i + 1);\n  }\n\n  return text;\n}\n\n// -- Types --------------------------------------------------------------------\nexport type ParserOptions = {\n  /**\n   * When `true`, an undefined named entity (like \"&bogus;\") will be left in the\n   * output as is instead of causing a parse error.\n   *\n   * @default false\n   */\n  ignoreUndefinedEntities?: boolean;\n\n  /**\n   * When `true`, the starting and ending byte offsets of each node in the input\n   * string will be made available via `start` and `end` properties on the node.\n   *\n   * @default false\n   */\n  includeOffsets?: boolean;\n\n  /**\n   * When `true`, CDATA sections will be preserved in the document as `XmlCdata`\n   * nodes. Otherwise CDATA sections will be represented as `XmlText` nodes,\n   * which keeps the node tree simpler and easier to work with.\n   *\n   * @default false\n   */\n  preserveCdata?: boolean;\n\n  /**\n   * When `true`, comments will be preserved in the document as `XmlComment`\n   * nodes. Otherwise comments will not be included in the node tree.\n   *\n   * @default false\n   */\n  preserveComments?: boolean;\n\n  /**\n   * When `true`, a document type declaration (if present) will be preserved in\n   * the document as an `XmlDocumentType` node. Otherwise the declaration will\n   * not be included in the node tree.\n   *\n   * Note that when this is `true` and a document type declaration is present,\n   * the DTD will precede the root node in the node tree (normally the root\n   * node would be first).\n   *\n   * @default false\n   */\n  preserveDocumentType?: boolean;\n\n  /**\n   * When `true`, an XML declaration (if present) will be preserved in the\n   * document as an `XmlDeclaration` node. Otherwise the declaration will not be\n   * included in the node tree.\n   *\n   * Note that when this is `true` and an XML declaration is present, the\n   * XML declaration will be the first child of the document (normally the root\n   * node would be first).\n   *\n   * @default false\n   */\n  preserveXmlDeclaration?: boolean;\n\n  /**\n   * When an undefined named entity is encountered, this function will be called\n   * with the entity as its only argument. It should return a string value with\n   * which to replace the entity, or `null` or `undefined` to treat the entity\n   * as undefined (which may result in a parse error depending on the value of\n   * `ignoreUndefinedEntities`).\n   */\n  resolveUndefinedEntity?: (entity: string) => string | null | undefined;\n\n  /**\n   * When `true`, attributes in an element's `attributes` object will be sorted\n   * in alphanumeric order by name. Otherwise they'll retain their original\n   * order as found in the XML.\n   *\n   * @default false\n   */\n  sortAttributes?: boolean;\n};\n"],
  "mappings": "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",
  "names": ["charCount", "charLength", "charIndex", "multiByteMode", "string", "charsToBytes", "isEnd", "advance", "charIndexToByteIndex", "consume", "peek", "consumeMatch", "consumeMatchFn", "consumeString", "consumeStringFast", "consumeUntilMatch", "consumeUntilString", "reset", "emptyString", "scanner", "currentNode", "options", "consumeStringFast", "consumeProlog", "consumeElement", "error", "consumeMisc", "isEnd", "addNode", "charIndexToByteIndex", "addText", "consumeAttributes", "consumeWhitespace", "consumeName", "consumeEqual", "consumeAttributeValue", "peek", "advance", "consumeMatch", "validateChars", "consumeReference", "consumeCdataSection", "charIndex", "consumeUntilString", "consumeCharData", "consumeUntilMatch", "consumeComment", "consumeContentReference", "consumeDoctypeDeclaration", "consumePubidLiteral", "consumeSystemLiteral", "reset", "consumeProcessingInstruction", "consumeMatchFn", "consumeXmlDeclaration", "consume", "string"]
}
