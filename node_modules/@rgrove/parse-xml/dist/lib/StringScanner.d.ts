/** @private */
export declare class StringScanner {
    charIndex: number;
    readonly string: string;
    private readonly charCount;
    private readonly charsToBytes;
    private readonly length;
    private readonly multiByteMode;
    constructor(string: string);
    /**
     * Whether the current character index is at the end of the input string.
     */
    get isEnd(): boolean;
    /**
     * Returns the number of characters in the given string, which may differ from
     * the byte length if the string contains multibyte characters.
     */
    protected charLength(string: string, multiByteSafe?: boolean): number;
    /**
     * Advances the scanner by the given number of characters, stopping if the end
     * of the string is reached.
     */
    advance(count?: number): void;
    /**
     * Returns the byte index of the given character index in the string. The two
     * may differ in strings that contain multibyte characters.
     */
    charIndexToByteIndex(charIndex?: number): number;
    /**
     * Consumes and returns the given number of characters if possible, advancing
     * the scanner and stopping if the end of the string is reached.
     *
     * If no characters could be consumed, an empty string will be returned.
     */
    consume(count?: number): string;
    /**
     * Consumes a match for the given sticky regex, advances the scanner, updates
     * the `lastIndex` property of the regex, and returns the matching string.
     *
     * The regex must have a sticky flag ("y") so that its `lastIndex` prop can be
     * used to anchor the match at the current scanner position.
     *
     * Returns the consumed string, or an empty string if nothing was consumed.
     */
    consumeMatch(regex: RegExp): string;
    /**
     * Consumes and returns all characters for which the given function returns a
     * truthy value, stopping on the first falsy return value or if the end of the
     * input is reached.
     */
    consumeMatchFn(fn: (char: string) => boolean): string;
    /**
     * Consumes the given string if it exists at the current character index, and
     * advances the scanner.
     *
     * If the given string doesn't exist at the current character index, an empty
     * string will be returned and the scanner will not be advanced.
     */
    consumeString(stringToConsume: string): string;
    /**
     * Does the same thing as `consumeString()`, but doesn't support consuming
     * multibyte characters. This can be faster if you only need to match single
     * byte characters.
     */
    consumeStringFast(stringToConsume: string): string;
    /**
     * Consumes characters until the given global regex is matched, advancing the
     * scanner up to (but not beyond) the beginning of the match. If the regex
     * doesn't match, nothing will be consumed.
     *
     * Returns the consumed string, or an empty string if nothing was consumed.
     */
    consumeUntilMatch(regex: RegExp): string;
    /**
     * Consumes characters until the given string is found, advancing the scanner
     * up to (but not beyond) that point. If the string is never found, nothing
     * will be consumed.
     *
     * Returns the consumed string, or an empty string if nothing was consumed.
     */
    consumeUntilString(searchString: string): string;
    /**
     * Returns the given number of characters starting at the current character
     * index, without advancing the scanner and without exceeding the end of the
     * input string.
     */
    peek(count?: number): string;
    /**
     * Resets the scanner position to the given character _index_, or to the start
     * of the input string if no index is given.
     *
     * If _index_ is negative, the scanner position will be moved backward by that
     * many characters, stopping if the beginning of the string is reached.
     */
    reset(index?: number): void;
}
//# sourceMappingURL=StringScanner.d.ts.map