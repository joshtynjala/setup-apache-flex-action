{
  "version": 3,
  "sources": ["../src/index.ts", "../src/lib/StringScanner.ts", "../src/lib/syntax.ts", "../src/lib/XmlNode.ts", "../src/lib/XmlText.ts", "../src/lib/XmlCdata.ts", "../src/lib/XmlComment.ts", "../src/lib/XmlDeclaration.ts", "../src/lib/XmlElement.ts", "../src/lib/XmlDocument.ts", "../src/lib/XmlDocumentType.ts", "../src/lib/XmlError.ts", "../src/lib/XmlProcessingInstruction.ts", "../src/lib/Parser.ts"],
  "sourcesContent": ["import { Parser } from './lib/Parser.js';\n\nimport type { ParserOptions } from './lib/Parser.js';\n\nexport * from './lib/types.js';\nexport { XmlCdata } from './lib/XmlCdata.js';\nexport { XmlComment } from './lib/XmlComment.js';\nexport { XmlDeclaration } from './lib/XmlDeclaration.js';\nexport { XmlDocument } from './lib/XmlDocument.js';\nexport { XmlDocumentType } from './lib/XmlDocumentType.js';\nexport { XmlElement } from './lib/XmlElement.js';\nexport { XmlError } from './lib/XmlError.js';\nexport { XmlNode } from './lib/XmlNode.js';\nexport { XmlProcessingInstruction } from './lib/XmlProcessingInstruction.js';\nexport { XmlText } from './lib/XmlText.js';\n\nexport type { ParserOptions } from './lib/Parser.js';\n\n/**\n * Parses the given XML string and returns an `XmlDocument` instance\n * representing the document tree.\n *\n * @example\n *\n * import { parseXml } from '@rgrove/parse-xml';\n * let doc = parseXml('<kittens fuzzy=\"yes\">I like fuzzy kittens.</kittens>');\n *\n * @param xml XML string to parse.\n * @param options Parser options.\n */\nexport function parseXml(xml: string, options?: ParserOptions) {\n  return (new Parser(xml, options)).document;\n}\n", "const emptyString = '';\nconst surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\n/** @private */\nexport class StringScanner {\n  charIndex: number;\n  readonly string: string;\n\n  private readonly charCount: number;\n  private readonly charsToBytes: number[] | undefined;\n  private readonly length: number;\n  private readonly multiByteMode: boolean;\n\n  constructor(string: string) {\n    this.charCount = this.charLength(string, true);\n    this.charIndex = 0;\n    this.length = string.length;\n    this.multiByteMode = this.charCount !== this.length;\n    this.string = string;\n\n    if (this.multiByteMode) {\n      let charsToBytes = [];\n\n      // Create a mapping of character indexes to byte indexes. Since the string\n      // contains multibyte characters, a byte index may not necessarily align\n      // with a character index.\n      for (let byteIndex = 0, charIndex = 0; charIndex < this.charCount; ++charIndex) {\n        charsToBytes[charIndex] = byteIndex;\n        byteIndex += (string.codePointAt(byteIndex) as number) > 65535 ? 2 : 1;\n      }\n\n      this.charsToBytes = charsToBytes;\n    }\n  }\n\n  /**\n   * Whether the current character index is at the end of the input string.\n   */\n  get isEnd() {\n    return this.charIndex >= this.charCount;\n  }\n\n  // -- Protected Methods ------------------------------------------------------\n\n  /**\n   * Returns the number of characters in the given string, which may differ from\n   * the byte length if the string contains multibyte characters.\n   */\n  protected charLength(string: string, multiByteSafe = this.multiByteMode): number {\n    // We could get the char length with `[ ...string ].length`, but that's\n    // actually slower than replacing surrogate pairs with single-byte\n    // characters and then counting the result.\n    return multiByteSafe\n      ? string.replace(surrogatePair, '_').length\n      : string.length;\n  }\n\n  // -- Public Methods ---------------------------------------------------------\n\n  /**\n   * Advances the scanner by the given number of characters, stopping if the end\n   * of the string is reached.\n   */\n  advance(count = 1) {\n    this.charIndex = Math.min(this.charCount, this.charIndex + count);\n  }\n\n  /**\n   * Returns the byte index of the given character index in the string. The two\n   * may differ in strings that contain multibyte characters.\n   */\n  charIndexToByteIndex(charIndex: number = this.charIndex): number {\n    return this.multiByteMode\n      ? (this.charsToBytes as number[])[charIndex] ?? Infinity\n      : charIndex;\n  }\n\n  /**\n   * Consumes and returns the given number of characters if possible, advancing\n   * the scanner and stopping if the end of the string is reached.\n   *\n   * If no characters could be consumed, an empty string will be returned.\n   */\n  consume(count = 1): string {\n    let chars = this.peek(count);\n    this.advance(count);\n    return chars;\n  }\n\n  /**\n   * Consumes a match for the given sticky regex, advances the scanner, updates\n   * the `lastIndex` property of the regex, and returns the matching string.\n   *\n   * The regex must have a sticky flag (\"y\") so that its `lastIndex` prop can be\n   * used to anchor the match at the current scanner position.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeMatch(regex: RegExp): string {\n    if (!regex.sticky) {\n      throw new Error('`regex` must have a sticky flag (\"y\")');\n    }\n\n    regex.lastIndex = this.charIndexToByteIndex();\n\n    let result = regex.exec(this.string);\n\n    if (result === null || result.length === 0) {\n      return emptyString;\n    }\n\n    let match = result[0] as string;\n    this.advance(this.charLength(match));\n    return match;\n  }\n\n  /**\n   * Consumes and returns all characters for which the given function returns a\n   * truthy value, stopping on the first falsy return value or if the end of the\n   * input is reached.\n   */\n  consumeMatchFn(fn: (char: string) => boolean): string {\n    let char;\n    let match = emptyString;\n\n    while ((char = this.peek()) && fn(char)) {\n      match += char;\n      this.advance();\n    }\n\n    return match;\n  }\n\n  /**\n   * Consumes the given string if it exists at the current character index, and\n   * advances the scanner.\n   *\n   * If the given string doesn't exist at the current character index, an empty\n   * string will be returned and the scanner will not be advanced.\n   */\n  consumeString(stringToConsume: string): string {\n    if (this.consumeStringFast(stringToConsume)) {\n      return stringToConsume;\n    }\n\n    if (this.multiByteMode) {\n      let { length } = stringToConsume;\n      let charLengthToMatch = this.charLength(stringToConsume);\n\n      if (charLengthToMatch !== length\n          && stringToConsume === this.peek(charLengthToMatch)) {\n\n        this.advance(charLengthToMatch);\n        return stringToConsume;\n      }\n    }\n\n    return emptyString;\n  }\n\n  /**\n   * Does the same thing as `consumeString()`, but doesn't support consuming\n   * multibyte characters. This can be faster if you only need to match single\n   * byte characters.\n   */\n  consumeStringFast(stringToConsume: string): string {\n    let { length } = stringToConsume;\n\n    if (this.peek(length) === stringToConsume) {\n      this.advance(length);\n      return stringToConsume;\n    }\n\n    return emptyString;\n  }\n\n  /**\n   * Consumes characters until the given global regex is matched, advancing the\n   * scanner up to (but not beyond) the beginning of the match. If the regex\n   * doesn't match, nothing will be consumed.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeUntilMatch(regex: RegExp): string {\n    let restOfString = this.string.slice(this.charIndexToByteIndex());\n    let matchByteIndex = restOfString.search(regex);\n\n    if (matchByteIndex <= 0) {\n      return emptyString;\n    }\n\n    let result = restOfString.slice(0, matchByteIndex);\n    this.advance(this.charLength(result));\n    return result;\n  }\n\n  /**\n   * Consumes characters until the given string is found, advancing the scanner\n   * up to (but not beyond) that point. If the string is never found, nothing\n   * will be consumed.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeUntilString(searchString: string): string {\n    let { string } = this;\n    let byteIndex = this.charIndexToByteIndex();\n    let matchByteIndex = string.indexOf(searchString, byteIndex);\n\n    if (matchByteIndex <= 0) {\n      return emptyString;\n    }\n\n    let result = string.slice(byteIndex, matchByteIndex);\n    this.advance(this.charLength(result));\n    return result;\n  }\n\n  /**\n   * Returns the given number of characters starting at the current character\n   * index, without advancing the scanner and without exceeding the end of the\n   * input string.\n   */\n  peek(count = 1): string {\n    let { charIndex, multiByteMode, string } = this;\n\n    if (multiByteMode) {\n      // Inlining this comparison instead of checking `this.isEnd` improves perf\n      // slightly since `peek()` is called so frequently.\n      if (charIndex >= this.charCount) {\n        return emptyString;\n      }\n\n      return string.slice(\n        this.charIndexToByteIndex(charIndex),\n        this.charIndexToByteIndex(charIndex + count),\n      );\n    }\n\n    return string.slice(charIndex, charIndex + count);\n  }\n\n  /**\n   * Resets the scanner position to the given character _index_, or to the start\n   * of the input string if no index is given.\n   *\n   * If _index_ is negative, the scanner position will be moved backward by that\n   * many characters, stopping if the beginning of the string is reached.\n   */\n  reset(index = 0) {\n    this.charIndex = index >= 0\n      ? Math.min(this.charCount, index)\n      : Math.max(0, this.charIndex + index);\n  }\n}\n", "/**\n * Regular expression that matches one or more `AttValue` characters in a\n * double-quoted attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n */\nexport const attValueCharDoubleQuote = /[^\"&<]+/y;\n\n/**\n * Regular expression that matches one or more `AttValue` characters in a\n * single-quoted attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n */\nexport const attValueCharSingleQuote = /[^'&<]+/y;\n\n/**\n * Regular expression that matches a whitespace character that should be\n * normalized to a space character in an attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#AVNormalize\n */\nexport const attValueNormalizedWhitespace = /\\r\\n|[\\n\\r\\t]/g;\n\n/**\n * Regular expression that matches one or more characters that signal the end of\n * XML `CharData` content.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n */\nexport const endCharData = /<|&|]]>/;\n\n/**\n * Mapping of predefined entity names to their replacement values.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent\n */\nexport const predefinedEntities: Readonly<{[name: string]: string;}> = Object.freeze(Object.assign(Object.create(null), {\n  amp: '&',\n  apos: \"'\",\n  gt: '>',\n  lt: '<',\n  quot: '\"',\n}));\n\n/**\n * Returns `true` if _char_ is an XML `NameChar`, `false` if it isn't.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameChar\n */\nexport function isNameChar(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  // Including the most common NameStartChars here improves performance\n  // slightly.\n  return (cp >= 0x61 && cp <= 0x7A) // a-z\n    || (cp >= 0x41 && cp <= 0x5A) // A-Z\n    || (cp >= 0x30 && cp <= 0x39) // 0-9\n    || cp === 0x2D // -\n    || cp === 0x2E // .\n    || cp === 0xB7\n    || (cp >= 0x300 && cp <= 0x36F)\n    || (cp >= 0x203F && cp <= 0x2040)\n    || isNameStartChar(char, cp);\n}\n\n/**\n * Returns `true` if _char_ is an XML `NameStartChar`, `false` if it isn't.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameStartChar\n */\nexport function isNameStartChar(char: string, cp = getCodePoint(char)): boolean {\n  return (cp >= 0x61 && cp <= 0x7A) // a-z\n    || (cp >= 0x41 && cp <= 0x5A) // A-Z\n    || cp === 0x3A // :\n    || cp === 0x5F // _\n    || (cp >= 0xC0 && cp <= 0xD6)\n    || (cp >= 0xD8 && cp <= 0xF6)\n    || (cp >= 0xF8 && cp <= 0x2FF)\n    || (cp >= 0x370 && cp <= 0x37D)\n    || (cp >= 0x37F && cp <= 0x1FFF)\n    || (cp >= 0x200C && cp <= 0x200D)\n    || (cp >= 0x2070 && cp <= 0x218F)\n    || (cp >= 0x2C00 && cp <= 0x2FEF)\n    || (cp >= 0x3001 && cp <= 0xD7FF)\n    || (cp >= 0xF900 && cp <= 0xFDCF)\n    || (cp >= 0xFDF0 && cp <= 0xFFFD)\n    || (cp >= 0x10000 && cp <= 0xEFFFF);\n}\n\n/**\n * Returns `true` if _char_ is a valid reference character (which may appear\n * between `&` and `;` in a reference), `false` otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-references\n */\nexport function isReferenceChar(char: string): boolean {\n  return char === '#' || isNameChar(char);\n}\n\n/**\n * Returns `true` if _char_ is an XML whitespace character, `false` otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n */\nexport function isWhitespace(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  return cp === 0x20\n    || cp === 0x9\n    || cp === 0xA\n    || cp === 0xD;\n}\n\n/**\n * Returns `true` if _codepoint_ is a valid XML `Char` code point, `false`\n * otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Char\n */\nexport function isXmlCodePoint(cp: number): boolean {\n  return cp === 0x9\n    || cp === 0xA\n    || cp === 0xD\n    || (cp >= 0x20 && cp <= 0xD7FF)\n    || (cp >= 0xE000 && cp <= 0xFFFD)\n    || (cp >= 0x10000 && cp <= 0x10FFFF);\n}\n\n/**\n * Returns the Unicode code point value of the given character, or `-1` if\n * _char_ is empty.\n */\nfunction getCodePoint(char: string): number {\n  return char.codePointAt(0) || -1;\n}\n", "import type { JsonObject } from './types.js';\nimport type { XmlDocument } from './XmlDocument.js';\nimport type { XmlElement } from './XmlElement.js';\n\n/**\n * Base interface for a node in an XML document.\n */\nexport class XmlNode {\n  /**\n   * Type value for an `XmlCdata` node.\n   */\n  static readonly TYPE_CDATA = 'cdata';\n\n  /**\n   * Type value for an `XmlComment` node.\n   */\n  static readonly TYPE_COMMENT = 'comment';\n\n  /**\n   * Type value for an `XmlDocument` node.\n   */\n  static readonly TYPE_DOCUMENT = 'document';\n\n  /**\n   * Type value for an `XmlDocumentType` node.\n   */\n  static readonly TYPE_DOCUMENT_TYPE = 'doctype';\n\n  /**\n   * Type value for an `XmlElement` node.\n   */\n  static readonly TYPE_ELEMENT = 'element';\n\n  /**\n   * Type value for an `XmlProcessingInstruction` node.\n   */\n  static readonly TYPE_PROCESSING_INSTRUCTION = 'pi';\n\n  /**\n   * Type value for an `XmlText` node.\n   */\n  static readonly TYPE_TEXT = 'text';\n\n  /**\n   * Type value for an `XmlDeclaration` node.\n   */\n  static readonly TYPE_XML_DECLARATION = 'xmldecl';\n\n  /**\n   * Parent node of this node, or `null` if this node has no parent.\n   */\n  parent: XmlDocument | XmlElement | null = null;\n\n  /**\n   * Starting byte offset of this node in the original XML string, or `-1` if\n   * the offset is unknown.\n   */\n  start = -1;\n\n  /**\n   * Ending byte offset of this node in the original XML string, or `-1` if the\n   * offset is unknown.\n   */\n  end = -1;\n\n  /**\n   * Document that contains this node, or `null` if this node is not associated\n   * with a document.\n   */\n  get document(): XmlDocument | null {\n    return this.parent?.document ?? null;\n  }\n\n  /**\n   * Whether this node is the root node of the document (also known as the\n   * document element).\n   */\n  get isRootNode(): boolean {\n    return this.parent !== null\n      && this.parent === this.document\n      && this.type === XmlNode.TYPE_ELEMENT;\n  }\n\n  /**\n   * Whether whitespace should be preserved in the content of this element and\n   * its children.\n   *\n   * This is influenced by the value of the special `xml:space` attribute, and\n   * will be `true` for any node whose `xml:space` attribute is set to\n   * \"preserve\". If a node has no such attribute, it will inherit the value of\n   * the nearest ancestor that does (if any).\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space\n   */\n  get preserveWhitespace(): boolean {\n    return !!this.parent?.preserveWhitespace;\n  }\n\n  /**\n   * Type of this node.\n   *\n   * The value of this property is a string that matches one of the static\n   * `TYPE_*` properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`,\n   * `TYPE_TEXT`, etc.).\n   *\n   * The `XmlNode` class itself is a base class and doesn't have its own type\n   * name.\n   */\n  get type() {\n    return '';\n  }\n\n  /**\n   * Returns a JSON-serializable object representing this node, minus properties\n   * that could result in circular references.\n   */\n  toJSON(): JsonObject {\n    let json: JsonObject = {\n      type: this.type,\n    };\n\n    if (this.isRootNode) {\n      json.isRootNode = true;\n    }\n\n    if (this.preserveWhitespace) {\n      json.preserveWhitespace = true;\n    }\n\n    if (this.start !== -1) {\n      json.start = this.start;\n      json.end = this.end;\n    }\n\n    return json;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * Text content within an XML document.\n */\nexport class XmlText extends XmlNode {\n  /**\n   * Text content of this node.\n   */\n  text: string;\n\n  constructor(text = '') {\n    super();\n    this.text = text;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_TEXT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      text: this.text,\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\nimport { XmlText } from './XmlText.js';\n\n/**\n * A CDATA section within an XML document.\n */\nexport class XmlCdata extends XmlText {\n  override get type() {\n    return XmlNode.TYPE_CDATA;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * A comment within an XML document.\n */\nexport class XmlComment extends XmlNode {\n  /**\n   * Content of this comment.\n   */\n  content: string;\n\n  constructor(content = '') {\n    super();\n    this.content = content;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_COMMENT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      content: this.content,\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * An XML declaration within an XML document.\n *\n * @example\n *\n * ```xml\n * <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n * ```\n */\nexport class XmlDeclaration extends XmlNode {\n  /**\n   * Value of the encoding declaration in this XML declaration, or `null` if no\n   * encoding declaration was present.\n   */\n  encoding: string | null;\n\n  /**\n   * Value of the standalone declaration in this XML declaration, or `null` if\n   * no standalone declaration was present.\n   */\n  standalone: 'yes' | 'no' | null;\n\n  /**\n   * Value of the version declaration in this XML declaration.\n   */\n  version: string;\n\n  constructor(\n    version: string,\n    encoding?: string,\n    standalone?: typeof XmlDeclaration.prototype.standalone,\n  ) {\n    super();\n\n    this.version = version;\n    this.encoding = encoding ?? null;\n    this.standalone = standalone ?? null;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_XML_DECLARATION;\n  }\n\n  override toJSON() {\n    let json = XmlNode.prototype.toJSON.call(this);\n    json.version = this.version;\n\n    for (let key of ['encoding', 'standalone'] as const) {\n      if (this[key] !== null) {\n        json[key] = this[key];\n      }\n    }\n\n    return json;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\nimport type { JsonObject } from './types.js';\nimport type { XmlCdata } from './XmlCdata.js';\nimport type { XmlComment } from './XmlComment.js';\nimport type { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\nimport type { XmlText } from './XmlText.js';\n\n/**\n * Element in an XML document.\n */\nexport class XmlElement extends XmlNode {\n  /**\n   * Attributes on this element.\n   */\n  attributes: {[attrName: string]: string};\n\n  /**\n   * Child nodes of this element.\n   */\n  children: Array<XmlCdata | XmlComment | XmlElement | XmlProcessingInstruction | XmlText>;\n\n  /**\n   * Name of this element.\n   */\n  name: string;\n\n  constructor(\n    name: string,\n    attributes: {[attrName: string]: string} = Object.create(null),\n    children: Array<XmlCdata | XmlComment | XmlElement | XmlProcessingInstruction | XmlText> = [],\n  ) {\n    super();\n\n    this.name = name;\n    this.attributes = attributes;\n    this.children = children;\n  }\n\n  /**\n   * Whether this element is empty (meaning it has no children).\n   */\n  get isEmpty(): boolean {\n    return this.children.length === 0;\n  }\n\n  override get preserveWhitespace(): boolean {\n    let node: XmlNode | null = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    while (node instanceof XmlElement) {\n      if ('xml:space' in node.attributes) {\n        return node.attributes['xml:space'] === 'preserve';\n      }\n\n      node = node.parent;\n    }\n\n    return false;\n  }\n\n  /**\n   * Text content of this element and all its descendants.\n   */\n  get text(): string {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  override get type() {\n    return XmlNode.TYPE_ELEMENT;\n  }\n\n  override toJSON(): JsonObject {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      attributes: this.attributes,\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n", "import { XmlElement } from './XmlElement.js';\nimport { XmlNode } from './XmlNode.js';\n\nimport type { XmlComment } from './XmlComment.js';\nimport type { XmlDeclaration } from './XmlDeclaration.js';\nimport type { XmlDocumentType } from './XmlDocumentType.js';\nimport type { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\n\n/**\n * Represents an XML document. All elements within the document are descendants\n * of this node.\n */\nexport class XmlDocument extends XmlNode {\n  /**\n   * Child nodes of this document.\n   */\n  readonly children: Array<XmlComment | XmlDeclaration | XmlDocumentType | XmlProcessingInstruction | XmlElement>;\n\n  constructor(children: Array<XmlComment | XmlDeclaration | XmlDocumentType | XmlElement | XmlProcessingInstruction> = []) {\n    super();\n    this.children = children;\n  }\n\n  override get document() {\n    return this;\n  }\n\n  /**\n   * Root element of this document, or `null` if this document is empty.\n   */\n  get root(): XmlElement | null {\n    for (let child of this.children) {\n      if (child instanceof XmlElement) {\n        return child;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Text content of this document and all its descendants.\n   */\n  get text(): string {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  override get type() {\n    return XmlNode.TYPE_DOCUMENT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * A document type declaration within an XML document.\n *\n * @example\n *\n * ```xml\n * <!DOCTYPE kittens [\n *   <!ELEMENT kittens (#PCDATA)>\n * ]>\n * ```\n */\nexport class XmlDocumentType extends XmlNode {\n  /**\n   * Name of the root element described by this document type declaration.\n   */\n  name: string;\n\n  /**\n   * Public identifier of the external subset of this document type declaration,\n   * or `null` if no public identifier was present.\n   */\n  publicId: string | null;\n\n  /**\n   * System identifier of the external subset of this document type declaration,\n   * or `null` if no system identifier was present.\n   */\n  systemId: string | null;\n\n  /**\n   * Internal subset of this document type declaration, or `null` if no internal\n   * subset was present.\n   */\n  internalSubset: string | null;\n\n  constructor(\n    name: string,\n    publicId?: string,\n    systemId?: string,\n    internalSubset?: string,\n  ) {\n    super();\n    this.name = name;\n    this.publicId = publicId ?? null;\n    this.systemId = systemId ?? null;\n    this.internalSubset = internalSubset ?? null;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_DOCUMENT_TYPE;\n  }\n\n  override toJSON() {\n    let json = XmlNode.prototype.toJSON.call(this);\n    json.name = this.name;\n\n    for (let key of ['publicId', 'systemId', 'internalSubset'] as const) {\n      if (this[key] !== null) {\n        json[key] = this[key];\n      }\n    }\n\n    return json;\n  }\n}\n", "/**\n * An error that occurred while parsing XML.\n */\nexport class XmlError extends Error {\n  /**\n   * Character column at which this error occurred (1-based).\n   */\n  readonly column: number;\n\n  /**\n   * Short excerpt from the input string that contains the problem.\n   */\n  readonly excerpt: string;\n\n  /**\n   * Line number at which this error occurred (1-based).\n   */\n  readonly line: number;\n\n  /**\n   * Character position at which this error occurred relative to the beginning\n   * of the input (0-based).\n   */\n  readonly pos: number;\n\n  constructor(\n    message: string,\n    charIndex: number,\n    xml: string,\n  ) {\n    let column = 1;\n    let excerpt = '';\n    let line = 1;\n\n    // Find the line and column where the error occurred.\n    for (let i = 0; i < charIndex; ++i) {\n      let char = xml[i];\n\n      if (char === '\\n') {\n        column = 1;\n        excerpt = '';\n        line += 1;\n      } else {\n        column += 1;\n        excerpt += char;\n      }\n    }\n\n    let eol = xml.indexOf('\\n', charIndex);\n\n    excerpt += eol === -1\n      ? xml.slice(charIndex)\n      : xml.slice(charIndex, eol);\n\n    let excerptStart = 0;\n\n    // Keep the excerpt below 50 chars, but always keep the error position in\n    // view.\n    if (excerpt.length > 50) {\n      if (column < 40) {\n        excerpt = excerpt.slice(0, 50);\n      } else {\n        excerptStart = column - 20;\n        excerpt = excerpt.slice(excerptStart, column + 30);\n      }\n    }\n\n    super(\n      `${message} (line ${line}, column ${column})\\n`\n        + `  ${excerpt}\\n`\n        + ' '.repeat(column - excerptStart + 1) + '^\\n',\n    );\n\n    this.column = column;\n    this.excerpt = excerpt;\n    this.line = line;\n    this.name = 'XmlError';\n    this.pos = charIndex;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * A processing instruction within an XML document.\n */\nexport class XmlProcessingInstruction extends XmlNode {\n  /**\n   * Content of this processing instruction.\n   */\n  content: string;\n\n  /**\n   * Name of this processing instruction. Also sometimes referred to as the\n   * processing instruction \"target\".\n   */\n  name: string;\n\n  constructor(name: string, content = '') {\n    super();\n\n    this.name = name;\n    this.content = content;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_PROCESSING_INSTRUCTION;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      content: this.content,\n    });\n  }\n}\n", "import { StringScanner } from './StringScanner.js';\nimport * as syntax from './syntax.js';\nimport { XmlCdata } from './XmlCdata.js';\nimport { XmlComment } from './XmlComment.js';\nimport { XmlDeclaration } from './XmlDeclaration.js';\nimport { XmlDocument } from './XmlDocument.js';\nimport { XmlDocumentType } from './XmlDocumentType.js';\nimport { XmlElement } from './XmlElement.js';\nimport { XmlError } from './XmlError.js';\nimport { XmlNode } from './XmlNode.js';\nimport { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\nimport { XmlText } from './XmlText.js';\n\nconst emptyString = '';\n\n/**\n * Parses an XML string into an `XmlDocument`.\n *\n * @private\n */\nexport class Parser {\n  readonly document: XmlDocument;\n\n  private currentNode: XmlDocument | XmlElement;\n  private readonly options: ParserOptions;\n  private readonly scanner: StringScanner;\n\n  /**\n   * @param xml XML string to parse.\n   * @param options Parser options.\n   */\n  constructor(xml: string, options: ParserOptions = {}) {\n    let doc = this.document = new XmlDocument();\n    let scanner = this.scanner = new StringScanner(xml);\n\n    this.currentNode = doc;\n    this.options = options;\n\n    if (this.options.includeOffsets) {\n      doc.start = 0;\n      doc.end = xml.length;\n    }\n\n    scanner.consumeStringFast('\\uFEFF'); // byte order mark\n    this.consumeProlog();\n\n    if (!this.consumeElement()) {\n      throw this.error('Root element is missing or invalid');\n    }\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (!scanner.isEnd) {\n      throw this.error('Extra content at the end of the document');\n    }\n  }\n\n  /**\n   * Adds the given `XmlNode` as a child of `this.currentNode`.\n   */\n  addNode(node: XmlNode, charIndex: number) {\n    node.parent = this.currentNode;\n\n    if (this.options.includeOffsets) {\n      node.start = this.scanner.charIndexToByteIndex(charIndex);\n      node.end = this.scanner.charIndexToByteIndex();\n    }\n\n    // @ts-expect-error: XmlDocument has a more limited set of possible children\n    // than XmlElement so TypeScript is unhappy, but we always do the right\n    // thing.\n    this.currentNode.children.push(node);\n    return true;\n  }\n\n  /**\n   * Adds the given _text_ to the document, either by appending it to a\n   * preceding `XmlText` node (if possible) or by creating a new `XmlText` node.\n   */\n  addText(text: string, charIndex: number) {\n    let { children } = this.currentNode;\n    let { length } = children;\n\n    text = normalizeLineBreaks(text);\n\n    if (length > 0) {\n      let prevNode = children[length - 1];\n\n      if (prevNode?.type === XmlNode.TYPE_TEXT) {\n        let textNode = prevNode as XmlText;\n\n        // The previous node is a text node, so we can append to it and avoid\n        // creating another node.\n        textNode.text += text;\n\n        if (this.options.includeOffsets) {\n          textNode.end = this.scanner.charIndexToByteIndex();\n        }\n\n        return true;\n      }\n    }\n\n    return this.addNode(new XmlText(text), charIndex);\n  }\n\n  /**\n   * Consumes element attributes.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-starttags\n   */\n  consumeAttributes(): Record<string, string> {\n    let attributes = Object.create(null);\n\n    while (this.consumeWhitespace()) {\n      let attrName = this.consumeName();\n\n      if (!attrName) {\n        break;\n      }\n\n      let attrValue = this.consumeEqual() && this.consumeAttributeValue();\n\n      if (attrValue === false) {\n        throw this.error('Attribute value expected');\n      }\n\n      if (attrName in attributes) {\n        throw this.error(`Duplicate attribute: ${attrName}`);\n      }\n\n      if (attrName === 'xml:space'\n          && attrValue !== 'default'\n          && attrValue !== 'preserve') {\n\n        throw this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n      }\n\n      attributes[attrName] = attrValue;\n    }\n\n    if (this.options.sortAttributes) {\n      let attrNames = Object.keys(attributes).sort();\n      let sortedAttributes = Object.create(null);\n\n      for (let i = 0; i < attrNames.length; ++i) {\n        let attrName = attrNames[i] as string;\n        sortedAttributes[attrName] = attributes[attrName];\n      }\n\n      attributes = sortedAttributes;\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Consumes an `AttValue` (attribute value) if possible.\n   *\n   * @returns\n   *   Contents of the `AttValue` minus quotes, or `false` if nothing was\n   *   consumed. An empty string indicates that an `AttValue` was consumed but\n   *   was empty.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n   */\n  consumeAttributeValue(): string | false {\n    let { scanner } = this;\n    let quote = scanner.peek();\n\n    if (quote !== '\"' && quote !== \"'\") {\n      return false;\n    }\n\n    scanner.advance();\n\n    let chars;\n    let isClosed = false;\n    let value = emptyString;\n    let regex = quote === '\"'\n      ? syntax.attValueCharDoubleQuote\n      : syntax.attValueCharSingleQuote;\n\n    matchLoop: while (!scanner.isEnd) {\n      chars = scanner.consumeMatch(regex);\n\n      if (chars) {\n        this.validateChars(chars);\n        value += chars.replace(syntax.attValueNormalizedWhitespace, ' ');\n      }\n\n      switch (scanner.peek()) {\n        case quote:\n          isClosed = true;\n          break matchLoop;\n\n        case '&':\n          value += this.consumeReference();\n          continue;\n\n        case '<':\n          throw this.error('Unescaped `<` is not allowed in an attribute value');\n\n        case emptyString:\n          break matchLoop;\n      }\n    }\n\n    if (!isClosed) {\n      throw this.error('Unclosed attribute');\n    }\n\n    scanner.advance();\n    return value;\n  }\n\n  /**\n   * Consumes a CDATA section if possible.\n   *\n   * @returns Whether a CDATA section was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n   */\n  consumeCdataSection(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<![CDATA[')) {\n      return false;\n    }\n\n    let text = scanner.consumeUntilString(']]>');\n    this.validateChars(text);\n\n    if (!scanner.consumeStringFast(']]>')) {\n      throw this.error('Unclosed CDATA section');\n    }\n\n    return this.options.preserveCdata\n      ? this.addNode(new XmlCdata(normalizeLineBreaks(text)), startIndex)\n      : this.addText(text, startIndex);\n  }\n\n  /**\n   * Consumes character data if possible.\n   *\n   * @returns Whether character data was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n   */\n  consumeCharData(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n    let charData = scanner.consumeUntilMatch(syntax.endCharData);\n\n    if (!charData) {\n      return false;\n    }\n\n    this.validateChars(charData);\n\n    if (scanner.peek(3) === ']]>') {\n      throw this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n    }\n\n    return this.addText(charData, startIndex);\n  }\n\n  /**\n   * Consumes a comment if possible.\n   *\n   * @returns Whether a comment was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n   */\n  consumeComment(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<!--')) {\n      return false;\n    }\n\n    let content = scanner.consumeUntilString('--');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('-->')) {\n      if (scanner.peek(2) === '--') {\n        throw this.error(\"The string `--` isn't allowed inside a comment\");\n      }\n\n      throw this.error('Unclosed comment');\n    }\n\n    return this.options.preserveComments\n      ? this.addNode(new XmlComment(normalizeLineBreaks(content)), startIndex)\n      : true;\n  }\n\n  /**\n   * Consumes a reference in a content context if possible.\n   *\n   * This differs from `consumeReference()` in that a consumed reference will be\n   * added to the document as a text node instead of returned.\n   *\n   * @returns Whether a reference was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n   */\n  consumeContentReference(): boolean {\n    let startIndex = this.scanner.charIndex;\n    let ref = this.consumeReference();\n\n    return ref\n      ? this.addText(ref, startIndex)\n      : false;\n  }\n\n  /**\n   * Consumes a doctype declaration if possible.\n   *\n   * This is a loose implementation since doctype declarations are currently\n   * discarded without further parsing.\n   *\n   * @returns Whether a doctype declaration was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n   */\n  consumeDoctypeDeclaration(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<!DOCTYPE')) {\n      return false;\n    }\n\n    let name = this.consumeWhitespace()\n      && this.consumeName();\n\n    if (!name) {\n      throw this.error('Expected a name');\n    }\n\n    let publicId;\n    let systemId;\n\n    if (this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('PUBLIC')) {\n        publicId = this.consumeWhitespace()\n          && this.consumePubidLiteral();\n\n        if (publicId === false) {\n          throw this.error('Expected a public identifier');\n        }\n\n        this.consumeWhitespace();\n      }\n\n      if (publicId !== undefined || scanner.consumeStringFast('SYSTEM')) {\n        this.consumeWhitespace();\n        systemId = this.consumeSystemLiteral();\n\n        if (systemId === false) {\n          throw this.error('Expected a system identifier');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    let internalSubset;\n\n    if (scanner.consumeStringFast('[')) {\n      // The internal subset may contain comments that contain `]` characters,\n      // so we can't use `consumeUntilString()` here.\n      internalSubset = scanner.consumeUntilMatch(/\\][\\x20\\t\\r\\n]*>/);\n\n      if (!scanner.consumeStringFast(']')) {\n        throw this.error('Unclosed internal subset');\n      }\n\n      this.consumeWhitespace();\n    }\n\n    if (!scanner.consumeStringFast('>')) {\n      throw this.error('Unclosed doctype declaration');\n    }\n\n    return this.options.preserveDocumentType\n      ? this.addNode(new XmlDocumentType(name, publicId, systemId, internalSubset), startIndex)\n      : true;\n    }\n\n  /**\n   * Consumes an element if possible.\n   *\n   * @returns Whether an element was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n   */\n  consumeElement(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (!name) {\n      scanner.reset(startIndex);\n      return false;\n    }\n\n    let attributes = this.consumeAttributes();\n    let isEmpty = !!scanner.consumeStringFast('/>');\n    let element = new XmlElement(name, attributes);\n\n    element.parent = this.currentNode;\n\n    if (!isEmpty) {\n      if (!scanner.consumeStringFast('>')) {\n        throw this.error(`Unclosed start tag for element \\`${name}\\``);\n      }\n\n      this.currentNode = element;\n\n      do {\n        this.consumeCharData();\n      } while (\n        this.consumeElement()\n          || this.consumeContentReference()\n          || this.consumeCdataSection()\n          || this.consumeProcessingInstruction()\n          || this.consumeComment()\n      );\n\n      let endTagMark = scanner.charIndex;\n      let endTagName;\n\n      if (!scanner.consumeStringFast('</')\n          || !(endTagName = this.consumeName())\n          || endTagName !== name) {\n\n        scanner.reset(endTagMark);\n        throw this.error(`Missing end tag for element ${name}`);\n      }\n\n      this.consumeWhitespace();\n\n      if (!scanner.consumeStringFast('>')) {\n        throw this.error(`Unclosed end tag for element ${name}`);\n      }\n\n      this.currentNode = element.parent;\n    }\n\n    return this.addNode(element, startIndex);\n  }\n\n  /**\n   * Consumes an `Eq` production if possible.\n   *\n   * @returns Whether an `Eq` production was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n   */\n  consumeEqual(): boolean {\n    this.consumeWhitespace();\n\n    if (this.scanner.consumeStringFast('=')) {\n      this.consumeWhitespace();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Consumes `Misc` content if possible.\n   *\n   * @returns Whether anything was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n   */\n  consumeMisc(): boolean {\n    return this.consumeComment()\n      || this.consumeProcessingInstruction()\n      || this.consumeWhitespace();\n  }\n\n  /**\n   * Consumes one or more `Name` characters if possible.\n   *\n   * @returns `Name` characters, or an empty string if none were consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n   */\n  consumeName(): string {\n    return syntax.isNameStartChar(this.scanner.peek())\n      ? this.scanner.consumeMatchFn(syntax.isNameChar)\n      : emptyString;\n  }\n\n  /**\n   * Consumes a processing instruction if possible.\n   *\n   * @returns Whether a processing instruction was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n   */\n  consumeProcessingInstruction(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (name) {\n      if (name.toLowerCase() === 'xml') {\n        scanner.reset(startIndex);\n        throw this.error(\"XML declaration isn't allowed here\");\n      }\n    } else {\n      throw this.error('Invalid processing instruction');\n    }\n\n    if (!this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('?>')) {\n        return this.addNode(new XmlProcessingInstruction(name), startIndex);\n      }\n\n      throw this.error('Whitespace is required after a processing instruction name');\n    }\n\n    let content = scanner.consumeUntilString('?>');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('?>')) {\n      throw this.error('Unterminated processing instruction');\n    }\n\n    return this.addNode(new XmlProcessingInstruction(name, normalizeLineBreaks(content)), startIndex);\n  }\n\n  /**\n   * Consumes a prolog if possible.\n   *\n   * @returns Whether a prolog was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n   */\n  consumeProlog(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    this.consumeXmlDeclaration();\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (this.consumeDoctypeDeclaration()) {\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n    }\n\n    return startIndex < scanner.charIndex;\n  }\n\n  /**\n   * Consumes a public identifier literal if possible.\n   *\n   * @returns\n   *   Value of the public identifier literal minus quotes, or `false` if\n   *   nothing was consumed. An empty string indicates that a public id literal\n   *   was consumed but was empty.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-PubidLiteral\n   */\n  consumePubidLiteral(): string | false {\n    let startIndex = this.scanner.charIndex;\n    let value = this.consumeSystemLiteral();\n\n    if (value !== false && !/^[-\\x20\\r\\na-zA-Z0-9'()+,./:=?;!*#@$_%]*$/.test(value)) {\n      this.scanner.reset(startIndex);\n      throw this.error('Invalid character in public identifier');\n    }\n\n    return value;\n  }\n\n  /**\n   * Consumes a reference if possible.\n   *\n   * This differs from `consumeContentReference()` in that a consumed reference\n   * will be returned rather than added to the document.\n   *\n   * @returns\n   *   Parsed reference value, or `false` if nothing was consumed (to\n   *   distinguish from a reference that resolves to an empty string).\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n   */\n  consumeReference(): string | false {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('&')) {\n      return false;\n    }\n\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n\n    if (scanner.consume() !== ';') {\n      throw this.error('Unterminated reference (a reference must end with `;`)');\n    }\n\n    let parsedValue;\n\n    if (ref[0] === '#') {\n      // This is a character reference.\n      let codePoint = ref[1] === 'x'\n        ? parseInt(ref.slice(2), 16) // Hex codepoint.\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n      if (isNaN(codePoint)) {\n        throw this.error('Invalid character reference');\n      }\n\n      if (!syntax.isXmlCodePoint(codePoint)) {\n        throw this.error('Character reference resolves to an invalid character');\n      }\n\n      parsedValue = String.fromCodePoint(codePoint);\n    } else {\n      // This is an entity reference.\n      parsedValue = syntax.predefinedEntities[ref];\n\n      if (parsedValue === undefined) {\n        let {\n          ignoreUndefinedEntities,\n          resolveUndefinedEntity,\n        } = this.options;\n\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n\n        if (resolveUndefinedEntity) {\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\n\n          if (resolvedValue !== null && resolvedValue !== undefined) {\n            let type = typeof resolvedValue;\n\n            if (type !== 'string') {\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n            }\n\n            return resolvedValue;\n          }\n        }\n\n        if (ignoreUndefinedEntities) {\n          return wrappedRef;\n        }\n\n        scanner.reset(-wrappedRef.length);\n        throw this.error(`Named entity isn't defined: ${wrappedRef}`);\n      }\n    }\n\n    return parsedValue;\n  }\n\n  /**\n   * Consumes a `SystemLiteral` if possible.\n   *\n   * A `SystemLiteral` is similar to an attribute value, but allows the\n   * characters `<` and `&` and doesn't replace references.\n   *\n   * @returns\n   *   Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n   *   consumed. An empty string indicates that a `SystemLiteral` was consumed\n   *   but was empty.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n   */\n  consumeSystemLiteral(): string | false {\n    let { scanner } = this;\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n\n    if (!quote) {\n      return false;\n    }\n\n    let value = scanner.consumeUntilString(quote);\n    this.validateChars(value);\n\n    if (!scanner.consumeStringFast(quote)) {\n      throw this.error('Missing end quote');\n    }\n\n    return value;\n  }\n\n  /**\n   * Consumes one or more whitespace characters if possible.\n   *\n   * @returns Whether any whitespace characters were consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n   */\n  consumeWhitespace(): boolean {\n    return !!this.scanner.consumeMatchFn(syntax.isWhitespace);\n  }\n\n  /**\n   * Consumes an XML declaration if possible.\n   *\n   * @returns Whether an XML declaration was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n   */\n  consumeXmlDeclaration(): boolean {\n    let { scanner } = this;\n    let startIndex = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?xml')) {\n      return false;\n    }\n\n    if (!this.consumeWhitespace()) {\n      throw this.error('Invalid XML declaration');\n    }\n\n    let version = !!scanner.consumeStringFast('version')\n      && this.consumeEqual()\n      && this.consumeSystemLiteral();\n\n    if (version === false) {\n      throw this.error('XML version is missing or invalid');\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\n      throw this.error('Invalid character in version number');\n    }\n\n    let encoding;\n    let standalone;\n\n    if (this.consumeWhitespace()) {\n      encoding = !!scanner.consumeStringFast('encoding')\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (encoding) {\n        this.consumeWhitespace();\n      }\n\n      standalone = !!scanner.consumeStringFast('standalone')\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (standalone) {\n        if (standalone !== 'yes' && standalone !== 'no') {\n          throw this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    if (!scanner.consumeStringFast('?>')) {\n      throw this.error('Invalid or unclosed XML declaration');\n    }\n\n    return this.options.preserveXmlDeclaration\n      ? this.addNode(new XmlDeclaration(\n          version,\n          encoding || undefined,\n          (standalone as 'yes' | 'no' | false) || undefined,\n        ), startIndex)\n      : true;\n  }\n\n  /**\n   * Returns an `XmlError` for the current scanner position.\n   */\n  error(message: string) {\n    let { scanner } = this;\n    return new XmlError(message, scanner.charIndex, scanner.string);\n  }\n\n  /**\n   * Throws an invalid character error if any character in the given _string_\n   * isn't a valid XML character.\n   */\n  validateChars(string: string) {\n    let { length } = string;\n\n    for (let i = 0; i < length; ++i) {\n      let cp = string.codePointAt(i) as number;\n\n      if (!syntax.isXmlCodePoint(cp)) {\n        this.scanner.reset(-([ ...string ].length - i));\n        throw this.error('Invalid character');\n      }\n\n      if (cp > 65535) {\n        i += 1;\n      }\n    }\n  }\n}\n\n// -- Private Functions --------------------------------------------------------\n\n/**\n * Normalizes line breaks in the given text by replacing CRLF sequences and lone\n * CR characters with LF characters.\n */\nfunction normalizeLineBreaks(text: string): string {\n  let i = 0;\n\n  while ((i = text.indexOf('\\r', i)) !== -1) {\n    text = text[i + 1] === '\\n'\n      ? text.slice(0, i) + text.slice(i + 1)\n      : text.slice(0, i) + '\\n' + text.slice(i + 1);\n  }\n\n  return text;\n}\n\n// -- Types --------------------------------------------------------------------\nexport type ParserOptions = {\n  /**\n   * When `true`, an undefined named entity (like \"&bogus;\") will be left in the\n   * output as is instead of causing a parse error.\n   *\n   * @default false\n   */\n  ignoreUndefinedEntities?: boolean;\n\n  /**\n   * When `true`, the starting and ending byte offsets of each node in the input\n   * string will be made available via `start` and `end` properties on the node.\n   *\n   * @default false\n   */\n  includeOffsets?: boolean;\n\n  /**\n   * When `true`, CDATA sections will be preserved in the document as `XmlCdata`\n   * nodes. Otherwise CDATA sections will be represented as `XmlText` nodes,\n   * which keeps the node tree simpler and easier to work with.\n   *\n   * @default false\n   */\n  preserveCdata?: boolean;\n\n  /**\n   * When `true`, comments will be preserved in the document as `XmlComment`\n   * nodes. Otherwise comments will not be included in the node tree.\n   *\n   * @default false\n   */\n  preserveComments?: boolean;\n\n  /**\n   * When `true`, a document type declaration (if present) will be preserved in\n   * the document as an `XmlDocumentType` node. Otherwise the declaration will\n   * not be included in the node tree.\n   *\n   * Note that when this is `true` and a document type declaration is present,\n   * the DTD will precede the root node in the node tree (normally the root\n   * node would be first).\n   *\n   * @default false\n   */\n  preserveDocumentType?: boolean;\n\n  /**\n   * When `true`, an XML declaration (if present) will be preserved in the\n   * document as an `XmlDeclaration` node. Otherwise the declaration will not be\n   * included in the node tree.\n   *\n   * Note that when this is `true` and an XML declaration is present, the\n   * XML declaration will be the first child of the document (normally the root\n   * node would be first).\n   *\n   * @default false\n   */\n  preserveXmlDeclaration?: boolean;\n\n  /**\n   * When an undefined named entity is encountered, this function will be called\n   * with the entity as its only argument. It should return a string value with\n   * which to replace the entity, or `null` or `undefined` to treat the entity\n   * as undefined (which may result in a parse error depending on the value of\n   * `ignoreUndefinedEntities`).\n   */\n  resolveUndefinedEntity?: (entity: string) => string | null | undefined;\n\n  /**\n   * When `true`, attributes in an element's `attributes` object will be sorted\n   * in alphanumeric order by name. Otherwise they'll retain their original\n   * order as found in the XML.\n   *\n   * @default false\n   */\n  sortAttributes?: boolean;\n};\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "XmlCdata", "XmlComment", "XmlDeclaration", "XmlDocument", "XmlDocumentType", "XmlElement", "XmlError", "XmlNode", "XmlProcessingInstruction", "XmlText", "parseXml", "emptyString", "surrogatePair", "StringScanner", "string", "charCount", "charLength", "charIndex", "multiByteMode", "charsToBytes", "byteIndex", "isEnd", "multiByteSafe", "advance", "count", "charIndexToByteIndex", "_a", "consume", "chars", "peek", "consumeMatch", "regex", "result", "match", "consumeMatchFn", "fn", "char", "consumeString", "stringToConsume", "consumeStringFast", "length", "charLengthToMatch", "consumeUntilMatch", "restOfString", "matchByteIndex", "consumeUntilString", "searchString", "reset", "index", "attValueCharDoubleQuote", "attValueCharSingleQuote", "attValueNormalizedWhitespace", "endCharData", "predefinedEntities", "isNameChar", "char", "cp", "getCodePoint", "isNameStartChar", "isReferenceChar", "isWhitespace", "isXmlCodePoint", "_XmlNode", "_a", "_b", "json", "XmlNode", "XmlText", "XmlNode", "text", "XmlCdata", "XmlText", "XmlNode", "XmlComment", "XmlNode", "content", "XmlDeclaration", "XmlNode", "version", "encoding", "standalone", "json", "key", "XmlElement", "XmlNode", "name", "attributes", "children", "node", "child", "XmlDocument", "XmlNode", "children", "child", "XmlElement", "XmlDocumentType", "XmlNode", "name", "publicId", "systemId", "internalSubset", "json", "key", "XmlError", "message", "charIndex", "xml", "column", "excerpt", "line", "i", "char", "eol", "excerptStart", "XmlProcessingInstruction", "XmlNode", "name", "content", "emptyString", "Parser", "xml", "options", "doc", "XmlDocument", "scanner", "StringScanner", "currentNode", "consumeStringFast", "consumeProlog", "consumeElement", "error", "consumeMisc", "isEnd", "addNode", "node", "charIndex", "charIndexToByteIndex", "addText", "text", "children", "length", "normalizeLineBreaks", "prevNode", "XmlNode", "textNode", "XmlText", "consumeAttributes", "attributes", "consumeWhitespace", "attrName", "consumeName", "attrValue", "consumeEqual", "consumeAttributeValue", "attrNames", "sortedAttributes", "quote", "peek", "advance", "chars", "isClosed", "value", "regex", "attValueCharDoubleQuote", "attValueCharSingleQuote", "matchLoop", "consumeMatch", "validateChars", "attValueNormalizedWhitespace", "consumeReference", "consumeCdataSection", "startIndex", "consumeUntilString", "XmlCdata", "consumeCharData", "charData", "consumeUntilMatch", "endCharData", "consumeComment", "content", "XmlComment", "consumeContentReference", "ref", "consumeDoctypeDeclaration", "name", "publicId", "systemId", "consumePubidLiteral", "consumeSystemLiteral", "internalSubset", "XmlDocumentType", "reset", "isEmpty", "element", "XmlElement", "consumeProcessingInstruction", "endTagMark", "endTagName", "isNameStartChar", "consumeMatchFn", "isNameChar", "XmlProcessingInstruction", "consumeXmlDeclaration", "isReferenceChar", "consume", "parsedValue", "codePoint", "isXmlCodePoint", "predefinedEntities", "ignoreUndefinedEntities", "resolveUndefinedEntity", "wrappedRef", "resolvedValue", "type", "isWhitespace", "version", "encoding", "standalone", "XmlDeclaration", "message", "XmlError", "string", "i", "cp", "parseXml", "xml", "options", "Parser"]
}
