'use strict';

var emptyArray = Object.freeze([]);
var emptyObject = Object.freeze(Object.create(null));
var namedEntities = Object.freeze({
  '&amp;': '&',
  '&apos;': "'",
  '&gt;': '>',
  '&lt;': '<',
  '&quot;': '"'
});
var NODE_TYPE_CDATA = 'cdata';
var NODE_TYPE_COMMENT = 'comment';
var NODE_TYPE_DOCUMENT = 'document';
var NODE_TYPE_ELEMENT = 'element';
var NODE_TYPE_TEXT = 'text';
var Syntax;

module.exports = function parseXml(xml, options) {
  if (options === void 0) {
    options = emptyObject;
  }

  if (Syntax === void 0) {
    // Lazy require to defer regex parsing until first use.
    Syntax = require('./lib/syntax');
  }

  if (xml[0] === "\uFEFF") {
    // Strip byte order mark.
    xml = xml.slice(1);
  }

  xml = xml.replace(/\r\n?/g, '\n'); // Normalize CRLF and CR to LF.

  var doc = {
    type: NODE_TYPE_DOCUMENT,
    children: [],
    parent: null,
    toJSON: nodeToJson
  };
  var state = {
    length: xml.length,
    options: options,
    parent: doc,
    pos: 0,
    prevPos: 0,
    xml: xml
  };
  state.replaceReference = replaceReference.bind(state);
  consumeProlog(state);

  if (!consumeElement(state)) {
    error(state, 'Root element is missing or invalid');
  }

  while (consumeMisc(state)) {} // eslint-disable-line no-empty


  if (!isEof(state)) {
    error(state, "Extra content at the end of the document");
  }

  return doc;
}; // -- Private Functions --------------------------------------------------------


function addNode(state, node) {
  node.parent = state.parent;
  node.toJSON = nodeToJson;
  state.parent.children.push(node);
}

function addText(state, text) {
  var children = state.parent.children;
  var prevNode = children[children.length - 1];

  if (prevNode !== void 0 && prevNode.type === NODE_TYPE_TEXT) {
    // The previous node is a text node, so we can append to it and avoid
    // creating another node.
    prevNode.text += text;
  } else {
    addNode(state, {
      type: NODE_TYPE_TEXT,
      text: text
    });
  }
} // Each `consume*` function takes the current state as an argument and returns
// `true` if `state.pos` was advanced (meaning some XML was consumed) or `false`
// if nothing was consumed.


function consumeCDSect(state) {
  var _scan = scan(state, Syntax.Anchored.CDSect),
      match = _scan[0],
      text = _scan[1];

  if (match === void 0) {
    return false;
  }

  if (state.options.preserveCdata) {
    addNode(state, {
      type: NODE_TYPE_CDATA,
      text: text
    });
  } else {
    addText(state, text);
  }

  return true;
}

function consumeCharData(state) {
  var _scan2 = scan(state, Syntax.Anchored.CharData),
      text = _scan2[0];

  if (text === void 0) {
    return false;
  }

  var cdataCloseIndex = text.indexOf(']]>');

  if (cdataCloseIndex !== -1) {
    state.pos = state.prevPos + cdataCloseIndex;
    error(state, 'Element content may not contain the CDATA section close delimiter `]]>`');
  } // Note: XML 1.0 5th ed. says `CharData` is "any string of characters which
  // does not contain the start-delimiter of any markup and does not include the
  // CDATA-section-close delimiter", but the conformance test suite and
  // well-established parsers like libxml seem to restrict `CharData` to
  // characters that match the `Char` symbol, so that's what I've done here.


  if (!Syntax.CharOnly.test(text)) {
    state.pos = state.prevPos + text.search(new RegExp("(?!" + Syntax.Char.source + ")"));
    error(state, 'Element content contains an invalid character');
  }

  addText(state, text);
  return true;
}

function consumeComment(state) {
  var _scan3 = scan(state, Syntax.Anchored.Comment),
      content = _scan3[1];

  if (content === void 0) {
    return false;
  }

  if (state.options.preserveComments) {
    addNode(state, {
      type: NODE_TYPE_COMMENT,
      content: content.trim()
    });
  }

  return true;
}

function consumeDoctypeDecl(state) {
  return scan(state, Syntax.Anchored.doctypedecl).length > 0;
}

function consumeElement(state) {
  var _scan4 = scan(state, Syntax.Anchored.EmptyElemTag),
      tag = _scan4[0],
      name = _scan4[1],
      attrs = _scan4[2];

  var isEmpty = tag !== void 0;

  if (!isEmpty) {
    var _scan5 = scan(state, Syntax.Anchored.STag);

    tag = _scan5[0];
    name = _scan5[1];
    attrs = _scan5[2];

    if (tag === void 0) {
      return false;
    }
  }

  var parent = state.parent;
  var parsedAttrs = parseAttrs(state, attrs);
  var node = {
    type: NODE_TYPE_ELEMENT,
    name: name,
    attributes: parsedAttrs,
    children: []
  };
  var xmlSpace = parsedAttrs['xml:space'];

  if (xmlSpace === 'preserve' || xmlSpace !== 'default' && parent.preserveWhitespace) {
    node.preserveWhitespace = true;
  }

  if (!isEmpty) {
    state.parent = node;
    consumeCharData(state);

    while (consumeElement(state) || consumeReference(state) || consumeCDSect(state) || consumePI(state) || consumeComment(state)) {
      consumeCharData(state);
    }

    var _scan6 = scan(state, Syntax.Anchored.ETag),
        endName = _scan6[1];

    if (endName !== name) {
      state.pos = state.prevPos;
      error(state, "Missing end tag for element " + name);
    }

    state.parent = parent;
  }

  addNode(state, node);
  return true;
}

function consumeMisc(state) {
  return consumeComment(state) || consumePI(state) || consumeWhitespace(state);
}

function consumePI(state) {
  var _scan7 = scan(state, Syntax.Anchored.PI),
      match = _scan7[0],
      target = _scan7[1];

  if (match === void 0) {
    return false;
  }

  if (target.toLowerCase() === 'xml') {
    state.pos = state.prevPos;
    error(state, 'XML declaration is only allowed at the start of the document');
  }

  return true;
}

function consumeProlog(state) {
  var pos = state.pos;
  scan(state, Syntax.Anchored.XMLDecl);

  while (consumeMisc(state)) {} // eslint-disable-line no-empty


  if (consumeDoctypeDecl(state)) {
    while (consumeMisc(state)) {} // eslint-disable-line no-empty

  }

  return state.pos > pos;
}

function consumeReference(state) {
  var _scan8 = scan(state, Syntax.Anchored.Reference),
      ref = _scan8[0];

  if (ref === void 0) {
    return false;
  }

  addText(state, state.replaceReference(ref));
  return true;
}

function consumeWhitespace(state) {
  return scan(state, Syntax.Anchored.S).length > 0;
}

function error(state, message) {
  var pos = state.pos,
      xml = state.xml;
  var column = 1;
  var excerpt = '';
  var line = 1; // Find the line and column where the error occurred.

  for (var i = 0; i < pos; ++i) {
    var _char = xml[i];

    if (_char === '\n') {
      column = 1;
      excerpt = '';
      line += 1;
    } else {
      column += 1;
      excerpt += _char;
    }
  }

  var eol = xml.indexOf('\n', pos);
  excerpt += eol === -1 ? xml.slice(pos) : xml.slice(pos, eol);
  var excerptStart = 0; // Keep the excerpt below 50 chars, but always keep the error position in
  // view.

  if (excerpt.length > 50) {
    if (column < 40) {
      excerpt = excerpt.slice(0, 50);
    } else {
      excerptStart = column - 20;
      excerpt = excerpt.slice(excerptStart, column + 30);
    }
  }

  var err = new Error(message + " (line " + line + ", column " + column + ")\n" + ("  " + excerpt + "\n") + ' '.repeat(column - excerptStart + 1) + '^\n');
  err.column = column;
  err.excerpt = excerpt;
  err.line = line;
  err.pos = pos;
  throw err;
}

function isEof(state) {
  return state.pos >= state.length - 1;
}

function nodeToJson() {
  var json = Object.assign(Object.create(null), this); // eslint-disable-line no-invalid-this

  delete json.parent;
  return json;
}

function normalizeAttrValue(state, value) {
  return value.replace(/[\x20\t\r\n]/g, ' ').replace(Syntax.Global.Reference, state.replaceReference);
}

function parseAttrs(state, attrs) {
  var parsedAttrs = Object.create(null);

  if (!attrs) {
    return parsedAttrs;
  }

  var attrPairs = attrs.match(Syntax.Global.Attribute).sort();

  for (var i = 0, len = attrPairs.length; i < len; ++i) {
    var attrPair = attrPairs[i];
    var eqMatch = attrPair.match(Syntax.Eq);
    var name = attrPair.slice(0, eqMatch.index);
    var value = attrPair.slice(eqMatch.index + eqMatch[0].length);

    if (name in parsedAttrs) {
      state.pos = state.prevPos;
      error(state, "Attribute `" + name + "` redefined");
    }

    value = normalizeAttrValue(state, value.slice(1, -1));

    if (name === 'xml:space') {
      if (value !== 'default' && value !== 'preserve') {
        state.pos = state.prevPos;
        error(state, "Value of the `xml:space` attribute must be \"default\" or \"preserve\"");
      }
    }

    parsedAttrs[name] = value;
  }

  return parsedAttrs;
}

function replaceReference(ref) {
  var state = this; // eslint-disable-line no-invalid-this

  if (ref[ref.length - 1] !== ';') {
    error(state, "Invalid reference: `" + ref + "`");
  }

  if (ref[1] === '#') {
    // This is a character entity.
    var codePoint;

    if (ref[2] === 'x') {
      codePoint = parseInt(ref.slice(3, -1), 16);
    } else {
      codePoint = parseInt(ref.slice(2, -1), 10);
    }

    if (isNaN(codePoint)) {
      state.pos = state.prevPos;
      error(state, "Invalid character entity `" + ref + "`");
    }

    var _char2 = String.fromCodePoint(codePoint);

    if (!Syntax.Char.test(_char2)) {
      state.pos = state.prevPos;
      error(state, "Invalid character entity `" + ref + "`");
    }

    return _char2;
  } // This is a named entity.


  var value = namedEntities[ref];

  if (value !== void 0) {
    return value;
  }

  if (state.options.resolveUndefinedEntity) {
    var resolvedValue = state.options.resolveUndefinedEntity(ref);

    if (resolvedValue !== null && resolvedValue !== void 0) {
      return resolvedValue;
    }
  }

  if (state.options.ignoreUndefinedEntities) {
    return ref;
  }

  state.pos = state.prevPos;
  error(state, "Named entity isn't defined: `" + ref + "`");
}

function scan(state, regex) {
  var pos = state.pos,
      xml = state.xml;
  var xmlToScan = pos > 0 ? xml.slice(pos) : xml;
  var matches = xmlToScan.match(regex);

  if (matches === null) {
    return emptyArray;
  }

  state.prevPos = state.pos;
  state.pos += matches[0].length;
  return matches;
}