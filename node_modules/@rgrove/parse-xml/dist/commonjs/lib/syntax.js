'use strict'; // To improve readability, the regular expression patterns in this file are
// written as tagged template literals. The `regex` tag function strips literal
// whitespace characters and line comments beginning with `//` and returns a
// RegExp instance.
//
// Escape sequences are preserved as-is in the resulting regex, so
// double-escaping isn't necessary. A pattern may embed another pattern using
// `${}` interpolation.
// -- Common Symbols -----------------------------------------------------------

function _templateObject18() {
  var data = _taggedTemplateLiteralLoose(["\n  <?xml\n    ", "\n    [sS]+?\n  ?>\n"], ["\n  <\\?xml\n    ", "\n    [\\s\\S]+?\n  \\?>\n"]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteralLoose(["\n  <?\n    // Group 1: PITarget\n    (\n      ", "\n    )\n\n    (?:\n      ", "\n      (?:", ")*?\n    )?\n  ?>\n"], ["\n  <\\?\n    // Group 1: PITarget\n    (\n      ", "\n    )\n\n    (?:\n      ", "\n      (?:", ")*?\n    )?\n  \\?>\n"]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _templateObject16() {
  var data = _taggedTemplateLiteralLoose(["\n  <!DOCTYPE\n    ", "\n\n    [^[>]*\n\n    (?:\n      [ [sS]+? ]\n      (?:", ")?\n    )?\n  >\n"], ["\n  <!DOCTYPE\n    ", "\n\n    [^[>]*\n\n    (?:\n      \\[ [\\s\\S]+? \\]\n      (?:", ")?\n    )?\n  >\n"]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteralLoose(["\n  <!--\n    // Group 1: Comment text (optional)\n    (\n      (?:\n        (?!-) ", "\n        | - (?!-) ", "\n      )*\n    )\n  -->\n"]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteralLoose(["\n  ^(?:", ")*$\n"]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteralLoose(["\n  <\n    // Group 1: Start tag name\n    (", ")\n\n    // Group 2: Attributes (optional)\n    (\n      (?:\n        ", "\n        ", "\n      )*\n    )\n\n    (?:", ")?\n  >\n"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteralLoose(["\n  </\n    // Group 1: End tag name\n    (", ")\n    (?:", ")?\n  >\n"]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteralLoose(["\n  <\n    // Group 1: Element name\n    (", ")\n\n    // Group 2: Attributes (optional)\n    (\n      (?:\n        ", "\n        ", "\n      )*\n    )\n\n    (?:", ")?\n  />\n"]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteralLoose(["\n  <![CDATA[\n    // Group 1: CData text content (optional)\n    (\n      (?:", ")*?\n    )\n  ]]>\n"], ["\n  <!\\[CDATA\\[\n    // Group 1: CData text content (optional)\n    (\n      (?:", ")*?\n    )\n  \\]\\]>\n"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteralLoose(["\n  ", "\n  ", "\n\n  (?:\n    \"(?:\n      [^<\"]\n    )*\"\n\n    |\n\n    '(?:\n      [^<']\n    )*'\n  )\n"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteralLoose(["\n  (?:", ")?\n  =\n  (?:", ")?\n"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteralLoose(["\n  [ \t\r\n]+\n"], ["\n  [\\x20\\t\\r\\n]+\n"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteralLoose(["\n  &[^s&;]*;?\n"], ["\n  &[^\\s&;]*;?\n"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteralLoose(["\n  ", "\n  (?:", ")*\n"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteralLoose(["\n  (?:\n    ", "\n\n    |\n\n    [\n      .\n      0-9\n      \xB7\n      \u0300-\u036F\n      \u203F-\u2040\n      -\n    ]\n  )\n"], ["\n  (?:\n    ", "\n\n    |\n\n    [\n      .\n      0-9\n      \\xB7\n      \\u0300-\\u036F\n      \\u203F-\\u2040\n      -\n    ]\n  )\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteralLoose(["\n  (?:\n    [\n      :\n      A-Z\n      _\n      a-z\n      \xC0-\xD6\n      \xD8-\xF6\n      \xF8-\u02FF\n      \u0370-\u037D\n      \u037F-\u1FFF\n      \u200C-\u200D\n      \u2070-\u218F\n      \u2C00-\u2FEF\n      \u3001-\uD7FF\n      \uF900-\uFDCF\n      \uFDF0-\uFFFD\n    ]\n\n    |\n\n    [\uD800-\uDB7F][\uDC00-\uDFFF]\n  )\n"], ["\n  (?:\n    [\n      :\n      A-Z\n      _\n      a-z\n      \\xC0-\\xD6\n      \\xD8-\\xF6\n      \\xF8-\\u02FF\n      \\u0370-\\u037D\n      \\u037F-\\u1FFF\n      \\u200C-\\u200D\n      \\u2070-\\u218F\n      \\u2C00-\\u2FEF\n      \\u3001-\\uD7FF\n      \\uF900-\\uFDCF\n      \\uFDF0-\\uFFFD\n    ]\n\n    |\n\n    [\\uD800-\\uDB7F][\\uDC00-\\uDFFF]\n  )\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteralLoose(["\n  [^<&]+\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteralLoose(["\n  (?:\n    [\n      \t\n      \n\n      \r\n       -\uD7FF\n      \uE000-\uFFFD\n    ]\n\n    |\n\n    [\uD800-\uDBFF][\uDC00-\uDFFF]\n  )\n"], ["\n  (?:\n    [\n      \\t\n      \\n\n      \\r\n      \\x20-\\uD7FF\n      \\uE000-\\uFFFD\n    ]\n\n    |\n\n    [\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\n  )\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

exports.Char = regex(_templateObject()); // Partial implementation.
//
// To be compliant, the matched text must result in an error if it contains the
// string `]]>`, but that can't be easily represented here so we do it in the
// parser.

exports.CharData = regex(_templateObject2());
exports.NameStartChar = regex(_templateObject3());
exports.NameChar = regex(_templateObject4(), exports.NameStartChar);
exports.Name = regex(_templateObject5(), exports.NameStartChar, exports.NameChar); // Loose implementation. The entity will be validated in the `replaceReference`
// function.

exports.Reference = regex(_templateObject6());
exports.S = regex(_templateObject7()); // -- Attributes ---------------------------------------------------------------

exports.Eq = regex(_templateObject8(), exports.S, exports.S);
exports.Attribute = regex(_templateObject9(), exports.Name, exports.Eq); // -- Elements -----------------------------------------------------------------

exports.CDSect = regex(_templateObject10(), exports.Char);
exports.EmptyElemTag = regex(_templateObject11(), exports.Name, exports.S, exports.Attribute, exports.S);
exports.ETag = regex(_templateObject12(), exports.Name, exports.S);
exports.STag = regex(_templateObject13(), exports.Name, exports.S, exports.Attribute, exports.S); // -- Misc ---------------------------------------------------------------------
// Special pattern that matches an entire string consisting only of `Char`
// characters.

exports.CharOnly = regex(_templateObject14(), exports.Char);
exports.Comment = regex(_templateObject15(), exports.Char, exports.Char); // Loose implementation since doctype declarations are discarded.
//
// It's not possible to fully parse a doctype declaration with a regex, but
// since we just discard them we can skip parsing the fiddly inner bits and use
// a regex to speed things up.

exports.doctypedecl = regex(_templateObject16(), exports.S, exports.S); // Loose implementation since processing instructions are discarded.

exports.PI = regex(_templateObject17(), exports.Name, exports.S, exports.Char); // Loose implementation since XML declarations are discarded.

exports.XMLDecl = regex(_templateObject18(), exports.S); // -- Helpers ------------------------------------------------------------------

exports.Anchored = {};
exports.Global = {}; // Create anchored and global variations of each pattern.

Object.keys(exports).forEach(function (name) {
  if (name !== 'Anchored' && name !== 'CharOnly' && name !== 'Global') {
    var pattern = exports[name];
    exports.Anchored[name] = new RegExp('^' + pattern.source);
    exports.Global[name] = new RegExp(pattern.source, 'g');
  }
});

function regex(strings) {
  var length = strings.length,
      raw = strings.raw;
  var lastIndex = length - 1;
  var pattern = '';

  for (var _len = arguments.length, embeddedPatterns = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    embeddedPatterns[_key - 1] = arguments[_key];
  }

  for (var i = 0; i < length; ++i) {
    pattern += raw[i].replace(/(^|[^\\])\/\/.*$/gm, '$1') // remove end-of-line comments
    .replace(/\s+/g, ''); // remove all whitespace

    if (i < lastIndex) {
      pattern += embeddedPatterns[i].source;
    }
  }

  return new RegExp(pattern);
}